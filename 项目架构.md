# ğŸ—ï¸ CuttingASMR.org å®Œæ•´é¡¹ç›®æ¶æ„æ–‡æ¡£

**é¡¹ç›®åç§°:** CuttingASMR.org - AI ASMRè§†é¢‘ç”Ÿæˆå¹³å°  
**ç‰ˆæœ¬:** v3.0 å®Œæ•´æ¶æ„ç‰ˆ  
**æ–‡æ¡£ç¼–å†™è€…:** ç³»ç»Ÿæ¶æ„å¸ˆ  
**æœ€åæ›´æ–°:** 2025-01-27  
**æ–‡æ¡£çŠ¶æ€:** å®Œæ•´ç‰ˆæœ¬

---

## ğŸ“‹ ç¬¬ä¸€éƒ¨åˆ†ï¼šé¡¹ç›®æ€»è§ˆä¸æˆ˜ç•¥å®šä½

### 1.1 é¡¹ç›®ç®€ä»‹ä¸æ„¿æ™¯

#### ğŸ¯ äº§å“å®šä½ä¸å¸‚åœºä»·å€¼

**æ ¸å¿ƒå®šä½**
CuttingASMR.org æ˜¯ä¸€ä¸ªåŸºäºäººå·¥æ™ºèƒ½çš„ASMRè§†é¢‘ç”Ÿæˆå¹³å°ï¼Œåˆ©ç”¨Google Veo3 Fast APIæŠ€æœ¯ä¸ºç”¨æˆ·æä¾›ä¸ªæ€§åŒ–çš„ASMRå†…å®¹åˆ›ä½œæœåŠ¡ã€‚æˆ‘ä»¬è‡´åŠ›äºæˆä¸ºASMRå†…å®¹åˆ›ä½œçš„æŠ€æœ¯å…ˆé©±å’Œè¡Œä¸šæ ‡å‡†åˆ¶å®šè€…ã€‚

**å¸‚åœºä»·å€¼ä¸»å¼ **
- ğŸš€ **æŠ€æœ¯åˆ›æ–°**ï¼šé¦–ä¸ªé‡‡ç”¨Google Veo3 Fastçš„ASMRä¸“ä¸šå¹³å°
- ğŸ’ **ç”¨æˆ·ä½“éªŒ**ï¼šç§’çº§å“åº”çš„AIè§†é¢‘ç”Ÿæˆï¼Œä¸“ä¸šçº§è§†è§‰æ•ˆæœ
- ğŸ¨ **å†…å®¹è´¨é‡**ï¼šåŸºäºä¸“ä¸šASMRç±»å‹åˆ†ç±»çš„é«˜è´¨é‡å†…å®¹è¾“å‡º
- ğŸ’° **å•†ä¸šæ¨¡å¼**ï¼šçº¯ç§¯åˆ†åˆ¶æ¶ˆè´¹ï¼Œé€æ˜å®šä»·ï¼Œç”¨æˆ·å‹å¥½

**ç›®æ ‡ç”¨æˆ·ç¾¤ä½“**
1. **ASMRå†…å®¹åˆ›ä½œè€…** - éœ€è¦é«˜è´¨é‡è§†é¢‘ç´ æçš„ä¸“ä¸šåˆ›ä½œè€…
2. **ASMRçˆ±å¥½è€…** - å¯»æ±‚ä¸ªæ€§åŒ–ASMRä½“éªŒçš„æ™®é€šç”¨æˆ·
3. **æ•°å­—è¥é”€ä»ä¸šè€…** - éœ€è¦ASMRé£æ ¼è¥é”€å†…å®¹çš„å•†ä¸šç”¨æˆ·
4. **ç ”ç©¶æœºæ„** - è¿›è¡ŒASMRç›¸å…³ç ”ç©¶çš„å­¦æœ¯æœºæ„

#### ğŸŒŸ æ ¸å¿ƒä¸šåŠ¡æ¨¡å¼åˆ†æ

**å•†ä¸šæ¨¡å¼åˆ›æ–°**
```
ä¼ ç»ŸASMRå¹³å°æ¨¡å¼ï¼šè®¢é˜…åˆ¶ + å¹¿å‘Šå˜ç°
    â†“ é—®é¢˜åˆ†æ
- ç”¨æˆ·ç²˜æ€§å·®ï¼Œå–æ¶ˆè®¢é˜…ç‡é«˜
- å¹¿å‘Šå½±å“ç”¨æˆ·ä½“éªŒ
- å†…å®¹è´¨é‡å‚å·®ä¸é½

CuttingASMRåˆ›æ–°æ¨¡å¼ï¼šAIç”Ÿæˆ + çº¯ç§¯åˆ†åˆ¶
    â†“ ä¼˜åŠ¿åˆ†æ
âœ… ç”¨æˆ·æŒ‰éœ€æ¶ˆè´¹ï¼Œæˆæœ¬å¯æ§
âœ… æ— å¹¿å‘Šå¹²æ‰°ï¼Œä¸“æ³¨ç”¨æˆ·ä½“éªŒ  
âœ… AIç”Ÿæˆä¿è¯å†…å®¹è´¨é‡ä¸€è‡´æ€§
âœ… æŠ€æœ¯å£å’é«˜ï¼Œç«äº‰ä¼˜åŠ¿æ˜æ˜¾
```

**æ”¶å…¥ç»“æ„åˆ†æ**
- **ä¸»è¦æ”¶å…¥æ¥æº**ï¼šç§¯åˆ†åŒ…é”€å”® (å æ¯”85%)
- **å¢å€¼æœåŠ¡æ”¶å…¥**ï¼šé«˜åˆ†è¾¨ç‡è§†é¢‘ã€æ‰¹é‡ç”Ÿæˆ (å æ¯”12%)
- **ä¼ä¸šæœåŠ¡æ”¶å…¥**ï¼šAPIæˆæƒã€å®šåˆ¶åŒ–æœåŠ¡ (å æ¯”3%)

#### ğŸ† æŠ€æœ¯åˆ›æ–°ç‚¹ä¸ç«äº‰ä¼˜åŠ¿

**æ ¸å¿ƒæŠ€æœ¯åˆ›æ–°**
1. **åŒAPIæ¶æ„è®¾è®¡**
   - é«˜çº§API + ç®€å•APIå›é€€æœºåˆ¶
   - 99.9%å¯ç”¨æ€§ä¿è¯
   - æˆæœ¬ä¼˜åŒ–ä¸ç”¨æˆ·ä½“éªŒå¹³è¡¡

2. **æ™ºèƒ½ç§¯åˆ†ç³»ç»Ÿ**
   - åŠ¨æ€å®šä»·ç®—æ³•
   - ç§¯åˆ†æ¢å¤æœºåˆ¶
   - æ¶ˆè´¹è¡Œä¸ºåˆ†æ

3. **Edge Runtimeä¼˜åŒ–**
   - å…¨çƒè¾¹ç¼˜è®¡ç®—éƒ¨ç½²
   - æ¯«ç§’çº§å“åº”æ—¶é—´
   - æ™ºèƒ½è´Ÿè½½å‡è¡¡

**ç«äº‰ä¼˜åŠ¿çŸ©é˜µ**
| ç»´åº¦ | CuttingASMR | ç«äº‰å¯¹æ‰‹A | ç«äº‰å¯¹æ‰‹B |
|------|-------------|-----------|-----------|
| æŠ€æœ¯å…ˆè¿›æ€§ | â­â­â­â­â­ | â­â­â­ | â­â­ |
| ç”¨æˆ·ä½“éªŒ | â­â­â­â­â­ | â­â­â­ | â­â­â­ |
| å†…å®¹è´¨é‡ | â­â­â­â­â­ | â­â­â­â­ | â­â­ |
| ä»·æ ¼ç«äº‰åŠ› | â­â­â­â­ | â­â­ | â­â­â­ |
| æŠ€æœ¯å£å’ | â­â­â­â­â­ | â­â­ | â­ |

#### ğŸ“ˆ é¡¹ç›®å‘å±•é˜¶æ®µä¸é‡Œç¨‹ç¢‘

**å‘å±•é˜¶æ®µè§„åˆ’**

**Phase 1: MVPéªŒè¯æœŸ (å·²å®Œæˆ)**
- âœ… æ ¸å¿ƒåŠŸèƒ½å¼€å‘å®Œæˆ
- âœ… æ”¯ä»˜ç³»ç»Ÿé›†æˆå®Œæˆ
- âœ… åŸºç¡€ç”¨æˆ·è®¤è¯ç³»ç»Ÿ
- âœ… åˆç‰ˆAIè§†é¢‘ç”ŸæˆåŠŸèƒ½

**Phase 2: äº§å“ä¼˜åŒ–æœŸ (å½“å‰é˜¶æ®µ)**
- ğŸ”„ åŒAPIæ¶æ„ä¼˜åŒ–
- ğŸ”„ ç”¨æˆ·ä½“éªŒæå‡
- ğŸ”„ æ€§èƒ½ç›‘æ§å®Œå–„
- ğŸ”„ ç§»åŠ¨ç«¯é€‚é…ä¼˜åŒ–

**Phase 3: è§„æ¨¡åŒ–å¢é•¿æœŸ (2025 Q2-Q4)**
- ğŸ¯ ç”¨æˆ·è·å–ç­–ç•¥æ‰§è¡Œ
- ğŸ¯ å†…å®¹ç”Ÿæ€å»ºè®¾
- ğŸ¯ APIå¼€æ”¾å¹³å°å»ºè®¾
- ğŸ¯ å›½é™…åŒ–å¸‚åœºæ‹“å±•

**Phase 4: ç”Ÿæ€å»ºè®¾æœŸ (2026å¹´)**
- ğŸš€ å¼€å‘è€…ç”Ÿæ€å»ºè®¾
- ğŸš€ ä¼ä¸šçº§æœåŠ¡æ¨å‡º
- ğŸš€ AIæŠ€æœ¯è¿­ä»£å‡çº§
- ğŸš€ è¡Œä¸šæ ‡å‡†åˆ¶å®šå‚ä¸

### 1.2 ä¸šåŠ¡æ¶æ„

#### ğŸ—ºï¸ ç”¨æˆ·æ—…ç¨‹åœ°å›¾

**æ–°ç”¨æˆ·è½¬åŒ–è·¯å¾„**
```mermaid
graph TD
    A[è®¿é—®é¦–é¡µ] --> B[äº†è§£äº§å“ä»·å€¼]
    B --> C[æŸ¥çœ‹è§†é¢‘å±•ç¤º]
    C --> D[æ³¨å†Œ/ç™»å½•]
    D --> E[è·å¾—å…è´¹ç§¯åˆ†]
    E --> F[ç”Ÿæˆç¬¬ä¸€ä¸ªè§†é¢‘]
    F --> G[ä½“éªŒæ»¡æ„?]
    G -->|æ˜¯| H[è´­ä¹°ç§¯åˆ†åŒ…]
    G -->|å¦| I[ä¼˜åŒ–å»ºè®®æ”¶é›†]
    H --> J[æˆä¸ºä»˜è´¹ç”¨æˆ·]
    I --> K[äº§å“æ”¹è¿›]
    K --> F
```

**ç”¨æˆ·ç”Ÿå‘½å‘¨æœŸç®¡ç†**
1. **æ–°æ‰‹å¼•å¯¼æœŸ (0-7å¤©)**
   - å…è´¹ç§¯åˆ†ä½“éªŒ
   - äº§å“åŠŸèƒ½ä»‹ç»
   - ä½¿ç”¨æŠ€å·§æŒ‡å¯¼

2. **æ´»è·ƒç”¨æˆ·æœŸ (7-30å¤©)**
   - ä¸ªæ€§åŒ–æ¨è
   - é«˜çº§åŠŸèƒ½æ¨å¹¿
   - ç¤¾åŒºäº’åŠ¨å¼•å¯¼

3. **å¿ å®ç”¨æˆ·æœŸ (30å¤©+)**
   - VIPæœåŠ¡ä½“éªŒ
   - æ–°åŠŸèƒ½ä¼˜å…ˆä½“éªŒ
   - æ¨èå¥–åŠ±æœºåˆ¶

#### ğŸ”„ ä¸šåŠ¡æµç¨‹å»ºæ¨¡

**æ ¸å¿ƒä¸šåŠ¡æµç¨‹**

**1. ç”¨æˆ·æ³¨å†Œä¸è®¤è¯æµç¨‹**
```
ç”¨æˆ·è®¿é—® â†’ Clerkè®¤è¯ â†’ ç”¨æˆ·ä¿¡æ¯åŒæ­¥ â†’ æ•°æ®åº“åˆ›å»ºç”¨æˆ·è®°å½• â†’ åˆ†é…åˆå§‹ç§¯åˆ† â†’ å®Œæˆæ³¨å†Œ
```

**2. è§†é¢‘ç”Ÿæˆæµç¨‹**
```
ç”¨æˆ·è¾“å…¥prompt â†’ ç§¯åˆ†éªŒè¯ â†’ APIå¯†é’¥åˆ†é… â†’ è°ƒç”¨Veo3 API â†’ ä»»åŠ¡çŠ¶æ€è·Ÿè¸ª â†’ è§†é¢‘ç”Ÿæˆå®Œæˆ â†’ ç»“æœè¿”å› â†’ ç§¯åˆ†æ‰£é™¤
```

**3. æ”¯ä»˜å¤„ç†æµç¨‹**
```
é€‰æ‹©ç§¯åˆ†åŒ… â†’ åŒAPIæ¶æ„å¤„ç† â†’ Creemæ”¯ä»˜ç½‘å…³ â†’ æ”¯ä»˜å®Œæˆ â†’ Webhookå›è°ƒ â†’ ç§¯åˆ†å‘æ”¾ â†’ ç”¨æˆ·é€šçŸ¥
```

#### ğŸ’° ä»·å€¼é“¾åˆ†æ

**ä»·å€¼åˆ›é€ é“¾**
```
AIæŠ€æœ¯æ¥å…¥ â†’ äº§å“å¼€å‘ â†’ ç”¨æˆ·è·å– â†’ å†…å®¹ç”Ÿæˆ â†’ ç”¨æˆ·ç•™å­˜ â†’ æ”¶å…¥å˜ç° â†’ æŠ€æœ¯å‡çº§
     â†‘                                                                    â†“
ç”¨æˆ·åé¦ˆ â† ç¤¾åŒºå»ºè®¾ â† å†…å®¹åˆ†äº« â† ç”¨æˆ·æ»¡æ„åº¦ â† æœåŠ¡è´¨é‡ â† å¹³å°ä¼˜åŒ– â† æ•°æ®åˆ†æ
```

**å…³é”®ä»·å€¼æ´»åŠ¨**
- **æŠ€æœ¯ç ”å‘**ï¼šAIç®—æ³•ä¼˜åŒ–ã€å¹³å°æ¶æ„å‡çº§
- **äº§å“è¿è¥**ï¼šç”¨æˆ·ä½“éªŒä¼˜åŒ–ã€åŠŸèƒ½è¿­ä»£
- **å¸‚åœºè¥é”€**ï¼šç”¨æˆ·è·å–ã€å“ç‰Œå»ºè®¾
- **å®¢æˆ·æœåŠ¡**ï¼šç”¨æˆ·æ”¯æŒã€é—®é¢˜è§£å†³

#### ğŸ¨ å•†ä¸šæ¨¡å¼ç”»å¸ƒ

**å…³é”®åˆä½œä¼™ä¼´**
- Google (Veo3 APIæä¾›å•†)
- Clerk (è®¤è¯æœåŠ¡æä¾›å•†)
- Creem (æ”¯ä»˜å¤„ç†å•†)
- Cloudflare (åŸºç¡€è®¾æ–½æœåŠ¡å•†)
- Railway (æ•°æ®åº“æœåŠ¡å•†)

**å…³é”®æ´»åŠ¨**
- AIè§†é¢‘ç”ŸæˆæŠ€æœ¯å¼€å‘
- ç”¨æˆ·ä½“éªŒè®¾è®¡ä¼˜åŒ–
- æ”¯ä»˜ç³»ç»Ÿç»´æŠ¤
- å®¢æˆ·æœåŠ¡æ”¯æŒ

**æ ¸å¿ƒèµ„æº**
- AIæŠ€æœ¯ä¸“åˆ©ä¸ç®—æ³•
- ç”¨æˆ·æ•°æ®ä¸è¡Œä¸ºåˆ†æ
- å“ç‰Œä»·å€¼ä¸å¸‚åœºè®¤çŸ¥
- æŠ€æœ¯å›¢é˜Ÿä¸è¿è¥å›¢é˜Ÿ

**ä»·å€¼ä¸»å¼ **
- é«˜è´¨é‡AIç”ŸæˆASMRè§†é¢‘
- ç®€å•æ˜“ç”¨çš„æ“ä½œç•Œé¢
- é€æ˜å…¬å¹³çš„ç§¯åˆ†å®šä»·
- å¿«é€Ÿå“åº”çš„å®¢æˆ·æœåŠ¡

**å®¢æˆ·å…³ç³»**
- è‡ªåŠ©æœåŠ¡å¹³å°
- ç¤¾åŒºæ”¯æŒ
- ä¸ªæ€§åŒ–æ¨è
- ä¼šå‘˜åˆ¶æœåŠ¡

**æ¸ é“é€šè·¯**
- å®˜æ–¹ç½‘ç«™
- ç¤¾äº¤åª’ä½“è¥é”€
- å†…å®¹åˆ›ä½œè€…åˆä½œ
- æœç´¢å¼•æ“ä¼˜åŒ–

**å®¢æˆ·ç»†åˆ†**
- ASMRå†…å®¹åˆ›ä½œè€…
- ASMRçˆ±å¥½è€…
- æ•°å­—è¥é”€ä»ä¸šè€…
- ç ”ç©¶æœºæ„

**æˆæœ¬ç»“æ„**
- AI APIè°ƒç”¨æˆæœ¬ (40%)
- æŠ€æœ¯å¼€å‘æˆæœ¬ (25%)
- åŸºç¡€è®¾æ–½æˆæœ¬ (20%)
- è¥é”€æ¨å¹¿æˆæœ¬ (15%)

**æ”¶å…¥æ¥æº**
- ç§¯åˆ†åŒ…é”€å”®æ”¶å…¥
- é«˜çº§åŠŸèƒ½è®¢é˜…
- ä¼ä¸šçº§APIæˆæƒ
- å®šåˆ¶åŒ–æœåŠ¡æ”¶å…¥

### 1.3 é¡¹ç›®ç®¡ç†æ¶æ„

#### ğŸ‘¥ å¼€å‘å›¢é˜Ÿç»“æ„

**æ ¸å¿ƒå›¢é˜Ÿç»„ç»‡æ¶æ„**
```
é¡¹ç›®æ€»è´Ÿè´£äºº
â”œâ”€â”€ æŠ€æœ¯æ¶æ„å¸ˆ (1äºº)
â”‚   â”œâ”€â”€ å‰ç«¯å¼€å‘å·¥ç¨‹å¸ˆ (2äºº)
â”‚   â”œâ”€â”€ åç«¯å¼€å‘å·¥ç¨‹å¸ˆ (2äºº)
â”‚   â””â”€â”€ DevOpså·¥ç¨‹å¸ˆ (1äºº)
â”œâ”€â”€ äº§å“ç»ç† (1äºº)
â”‚   â”œâ”€â”€ UI/UXè®¾è®¡å¸ˆ (1äºº)
â”‚   â””â”€â”€ æ•°æ®åˆ†æå¸ˆ (1äºº)
â””â”€â”€ è¿è¥æ€»ç›‘ (1äºº)
    â”œâ”€â”€ å†…å®¹è¿è¥ (1äºº)
    â””â”€â”€ ç”¨æˆ·è¿è¥ (1äºº)
```

**è§’è‰²ä¸èŒè´£åˆ†å·¥**
- **æŠ€æœ¯æ¶æ„å¸ˆ**ï¼šç³»ç»Ÿè®¾è®¡ã€æŠ€æœ¯é€‰å‹ã€æ¶æ„å†³ç­–
- **å‰ç«¯å·¥ç¨‹å¸ˆ**ï¼šç”¨æˆ·ç•Œé¢å¼€å‘ã€äº¤äº’ä¼˜åŒ–ã€æ€§èƒ½ä¼˜åŒ–
- **åç«¯å·¥ç¨‹å¸ˆ**ï¼šAPIå¼€å‘ã€æ•°æ®åº“è®¾è®¡ã€ä¸šåŠ¡é€»è¾‘å®ç°
- **DevOpså·¥ç¨‹å¸ˆ**ï¼šéƒ¨ç½²è‡ªåŠ¨åŒ–ã€ç›‘æ§å‘Šè­¦ã€æ€§èƒ½è°ƒä¼˜
- **äº§å“ç»ç†**ï¼šéœ€æ±‚åˆ†æã€äº§å“è§„åˆ’ã€é¡¹ç›®åè°ƒ
- **UI/UXè®¾è®¡å¸ˆ**ï¼šç•Œé¢è®¾è®¡ã€ç”¨æˆ·ä½“éªŒä¼˜åŒ–ã€è§†è§‰è§„èŒƒ
- **æ•°æ®åˆ†æå¸ˆ**ï¼šä¸šåŠ¡æŒ‡æ ‡åˆ†æã€ç”¨æˆ·è¡Œä¸ºç ”ç©¶ã€å†³ç­–æ”¯æŒ

#### ğŸ“Š é¡¹ç›®ç®¡ç†æ–¹æ³•è®º

**æ•æ·å¼€å‘æµç¨‹**
- **Sprintå‘¨æœŸ**ï¼š2å‘¨ä¸ºä¸€ä¸ªå¼€å‘å‘¨æœŸ
- **æ—¥å¸¸æµç¨‹**ï¼šæ¯æ—¥ç«™ä¼šã€Sprintè®¡åˆ’ä¼šã€å›é¡¾ä¼š
- **å·¥å…·ä½¿ç”¨**ï¼šGitHub Issues + Projectsçœ‹æ¿ç®¡ç†

**ç‰ˆæœ¬ç®¡ç†ç­–ç•¥**
```
ä¸»åˆ†æ”¯ç­–ç•¥ï¼šGitFlow
â”œâ”€â”€ main (ç”Ÿäº§ç¯å¢ƒ)
â”œâ”€â”€ develop (å¼€å‘ç¯å¢ƒ)  
â”œâ”€â”€ feature/* (åŠŸèƒ½åˆ†æ”¯)
â”œâ”€â”€ hotfix/* (ç´§æ€¥ä¿®å¤)
â””â”€â”€ release/* (å‘å¸ƒåˆ†æ”¯)
```

**ä»£ç å®¡æŸ¥æµç¨‹**
1. å¼€å‘è€…æäº¤Pull Request
2. è‡³å°‘2äººä»£ç å®¡æŸ¥é€šè¿‡
3. è‡ªåŠ¨åŒ–æµ‹è¯•é€šè¿‡
4. éƒ¨ç½²åˆ°æµ‹è¯•ç¯å¢ƒéªŒè¯
5. åˆå¹¶åˆ°ç›®æ ‡åˆ†æ”¯

#### âœ… è´¨é‡ä¿è¯æµç¨‹

**è´¨é‡ä¿è¯ä½“ç³»**
- **ä»£ç è´¨é‡**ï¼šESLint + Prettier + TypeScriptä¸¥æ ¼æ¨¡å¼
- **æµ‹è¯•è¦†ç›–ç‡**ï¼šå•å…ƒæµ‹è¯•è¦†ç›–ç‡â‰¥80%ï¼Œé›†æˆæµ‹è¯•è¦†ç›–æ ¸å¿ƒåŠŸèƒ½
- **æ€§èƒ½ç›‘æ§**ï¼šCore Web Vitalsç›‘æ§ï¼ŒAPIå“åº”æ—¶é—´ç›‘æ§
- **å®‰å…¨æ‰«æ**ï¼šä¾èµ–å®‰å…¨æ‰«æï¼Œä»£ç å®‰å…¨å®¡è®¡

**ç¼ºé™·ç®¡ç†æµç¨‹**
1. ç¼ºé™·å‘ç°ä¸è®°å½•
2. ä¸¥é‡çº§åˆ«è¯„ä¼°
3. è´£ä»»äººåˆ†é…
4. ä¿®å¤éªŒè¯
5. å›å½’æµ‹è¯•
6. å…³é—­ç¡®è®¤

#### âš ï¸ é£é™©ç®¡æ§æœºåˆ¶

**æŠ€æœ¯é£é™©è¯†åˆ«ä¸åº”å¯¹**
| é£é™©ç±»å‹ | é£é™©æè¿° | æ¦‚ç‡ | å½±å“ | åº”å¯¹ç­–ç•¥ |
|----------|----------|------|------|----------|
| APIä¾èµ–é£é™© | Google Veo3 APIä¸å¯ç”¨ | ä¸­ | é«˜ | å¤šAPIä¾›åº”å•†ã€é™çº§æ–¹æ¡ˆ |
| æ€§èƒ½é£é™© | é«˜å¹¶å‘ä¸‹ç³»ç»Ÿæ€§èƒ½ä¸‹é™ | ä¸­ | ä¸­ | è´Ÿè½½æµ‹è¯•ã€æ‰©å®¹é¢„æ¡ˆ |
| æ•°æ®é£é™© | æ•°æ®åº“æ•…éšœå¯¼è‡´æ•°æ®ä¸¢å¤± | ä½ | é«˜ | è‡ªåŠ¨å¤‡ä»½ã€å¼‚åœ°å®¹ç¾ |
| å®‰å…¨é£é™© | ç”¨æˆ·æ•°æ®æ³„éœ² | ä½ | é«˜ | å®‰å…¨å®¡è®¡ã€æ•°æ®åŠ å¯† |
| æ”¯ä»˜é£é™© | æ”¯ä»˜ç³»ç»Ÿæ•…éšœ | ä½ | ä¸­ | åŒAPIæ¶æ„ã€ç›‘æ§å‘Šè­¦ |

**ä¸šåŠ¡é£é™©ç®¡æ§**
- **å¸‚åœºé£é™©**ï¼šæŒç»­å¸‚åœºè°ƒç ”ã€ç«å“åˆ†æã€ç”¨æˆ·åé¦ˆæ”¶é›†
- **æ³•å¾‹é£é™©**ï¼šéšç§æ”¿ç­–åˆè§„ã€ç”¨æˆ·åè®®æ›´æ–°ã€çŸ¥è¯†äº§æƒä¿æŠ¤
- **è´¢åŠ¡é£é™©**ï¼šæˆæœ¬æ§åˆ¶ã€æ”¶å…¥é¢„æµ‹ã€ç°é‡‘æµç®¡ç†

**åº”æ€¥å“åº”æœºåˆ¶**
1. **æ•…éšœå‘ç°**ï¼šç›‘æ§å‘Šè­¦ã€ç”¨æˆ·åé¦ˆ
2. **å¿«é€Ÿå“åº”**ï¼š15åˆ†é’Ÿå†…å“åº”ã€30åˆ†é’Ÿå†…å®šä½
3. **é—®é¢˜è§£å†³**ï¼š2å°æ—¶å†…ä¸´æ—¶æ–¹æ¡ˆã€24å°æ—¶å†…æ ¹æœ¬è§£å†³
4. **äº‹åæ€»ç»“**ï¼šæ•…éšœå¤ç›˜ã€æµç¨‹ä¼˜åŒ–ã€é¢„é˜²æªæ–½

---

## ğŸ¯ ç¬¬äºŒéƒ¨åˆ†ï¼šæŠ€æœ¯æ¶æ„è®¾è®¡

### 2.1 æ•´ä½“æŠ€æœ¯æ¶æ„

#### ğŸ—ï¸ ç³»ç»Ÿæ¶æ„å›¾ï¼ˆé«˜å±‚è§†å›¾ï¼‰

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                           ç”¨æˆ·è®¿é—®å±‚ (Global CDN)                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                        Cloudflare Global Network                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚
â”‚  â”‚   Asia-HK   â”‚  â”‚   US-West   â”‚  â”‚   EU-London â”‚  â”‚   å…¶ä»–èŠ‚ç‚¹   â”‚             â”‚
â”‚  â”‚  Edge Node  â”‚  â”‚  Edge Node  â”‚  â”‚  Edge Node  â”‚  â”‚  Edge Node  â”‚             â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                       â”‚
                                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        åº”ç”¨æœåŠ¡å±‚ (Multi-Platform)                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                      Cloudflare Pages + Railway                                â”‚
â”‚                                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚    Cloudflare Pages     â”‚           â”‚       Railway (å¤‡ç”¨)                â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚           â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚  â”‚
â”‚  â”‚  â”‚   Edge Runtime      â”‚â”‚  Failover â”‚  â”‚     Node.js Runtime           â”‚â”‚  â”‚
â”‚  â”‚  â”‚  - é™æ€è·¯ç”±         â”‚â”‚  â”€â”€â”€â”€â”€â”€â”€â–º â”‚  â”‚  - å¤æ‚ä¸šåŠ¡é€»è¾‘                â”‚â”‚  â”‚
â”‚  â”‚  â”‚  - ç®€å•API         â”‚â”‚           â”‚  â”‚  - æ•°æ®åº“å¯†é›†æ“ä½œ              â”‚â”‚  â”‚
â”‚  â”‚  â”‚  - ç¼“å­˜ä¼˜åŒ–         â”‚â”‚           â”‚  â”‚  - é•¿æ—¶é—´è¿è¡Œä»»åŠ¡              â”‚â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚           â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                       â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â–¼                  â–¼                  â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚   Authentication â”‚ â”‚   Data Storage  â”‚ â”‚  External APIs  â”‚
        â”‚                 â”‚ â”‚                 â”‚ â”‚                 â”‚
        â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
        â”‚  â”‚    Clerk    â”‚ â”‚ â”‚ â”‚   Railway   â”‚ â”‚ â”‚ â”‚ Google Veo3 â”‚ â”‚
        â”‚  â”‚    Auth     â”‚ â”‚ â”‚ â”‚ PostgreSQL  â”‚ â”‚ â”‚ â”‚  Fast API   â”‚ â”‚
        â”‚  â”‚   Service   â”‚ â”‚ â”‚ â”‚  Database   â”‚ â”‚ â”‚ â”‚             â”‚ â”‚
        â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
        â”‚                 â”‚ â”‚                 â”‚ â”‚                 â”‚
        â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
        â”‚  â”‚  JWT Token  â”‚ â”‚ â”‚ â”‚   Prisma    â”‚ â”‚ â”‚ â”‚    Creem    â”‚ â”‚
        â”‚  â”‚ Management  â”‚ â”‚ â”‚ â”‚     ORM     â”‚ â”‚ â”‚ â”‚  Payment    â”‚ â”‚
        â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚ â”‚   Gateway   â”‚ â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
                                                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### ğŸš€ å¾®æœåŠ¡æ¶æ„è®¾è®¡

**æœåŠ¡åˆ†å±‚æ¶æ„**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    è¡¨ç°å±‚ (Presentation Layer)               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  React Components + Next.js Pages + TailwindCSS            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚   Layout    â”‚ â”‚   Pages     â”‚ â”‚ Components  â”‚           â”‚
â”‚  â”‚ Components  â”‚ â”‚ (25 pages)  â”‚ â”‚  (8 core)   â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
                                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     ä¸šåŠ¡å±‚ (Business Layer)                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚              Next.js API Routes (Edge + Node.js)           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚   Auth      â”‚ â”‚   Video     â”‚ â”‚  Payment    â”‚           â”‚
â”‚  â”‚  Service    â”‚ â”‚  Service    â”‚ â”‚  Service    â”‚           â”‚
â”‚  â”‚  (5 APIs)   â”‚ â”‚ (8 APIs)    â”‚ â”‚ (6 APIs)    â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚   User      â”‚ â”‚   Admin     â”‚ â”‚  Webhook    â”‚           â”‚
â”‚  â”‚  Service    â”‚ â”‚  Service    â”‚ â”‚  Service    â”‚           â”‚
â”‚  â”‚  (7 APIs)   â”‚ â”‚ (3 APIs)    â”‚ â”‚ (4 APIs)    â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
                                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    æ•°æ®å±‚ (Data Access Layer)               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                     Prisma ORM + PostgreSQL                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚    User     â”‚ â”‚   Video     â”‚ â”‚  Purchase   â”‚           â”‚
â”‚  â”‚   Model     â”‚ â”‚   Model     â”‚ â”‚   Model     â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â”‚                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚  AuditLog   â”‚ â”‚ AdminLog    â”‚ â”‚  Settings   â”‚           â”‚
â”‚  â”‚   Model     â”‚ â”‚   Model     â”‚ â”‚   Model     â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### ğŸ”§ æŠ€æœ¯æ ˆé€‰å‹ä¾æ®

**å‰ç«¯æŠ€æœ¯æ ˆé€‰å‹åˆ†æ**
| æŠ€æœ¯ | é€‰å‹åŸå›  | æ›¿ä»£æ–¹æ¡ˆ | ä¼˜åŠ¿ |
|------|----------|----------|------|
| Next.js 15.2.3 | å…¨æ ˆæ¡†æ¶ï¼ŒSEOä¼˜åŒ–ï¼ŒEdge Runtimeæ”¯æŒ | Remix, SvelteKit | ğŸš€ æœåŠ¡ç«¯æ¸²æŸ“ + é™æ€ç”Ÿæˆ |
| React 18 | ç”Ÿæ€å®Œå–„ï¼Œå¹¶å‘ç‰¹æ€§ï¼Œå¼€å‘æ•ˆç‡ | Vue.js, Svelte | ğŸ¯ ä¸°å¯Œçš„ç”Ÿæ€ç³»ç»Ÿ |
| TypeScript | ç±»å‹å®‰å…¨ï¼Œå¼€å‘ä½“éªŒï¼Œä»£ç è´¨é‡ | JavaScript, Flow | âœ… ç¼–è¯‘æ—¶é”™è¯¯æ£€æŸ¥ |
| TailwindCSS | åŸå­åŒ–CSSï¼Œå¿«é€Ÿå¼€å‘ï¼Œä¸€è‡´æ€§ | Styled-components, CSS Modules | ğŸ¨ è®¾è®¡ç³»ç»Ÿä¸€è‡´æ€§ |

**åç«¯æŠ€æœ¯æ ˆé€‰å‹åˆ†æ**
| æŠ€æœ¯ | é€‰å‹åŸå›  | æ›¿ä»£æ–¹æ¡ˆ | ä¼˜åŠ¿ |
|------|----------|----------|------|
| Next.js API Routes | å…¨æ ˆä¸€ä½“åŒ–ï¼Œéƒ¨ç½²ç®€å•ï¼Œç±»å‹å…±äº« | Express.js, Fastify | ğŸ”„ å‰åç«¯ä»£ç å¤ç”¨ |
| Prisma ORM | ç±»å‹å®‰å…¨ï¼Œä»£ç ç”Ÿæˆï¼Œè¿ç§»ç®¡ç† | TypeORM, Sequelize | ğŸ›¡ï¸ æ•°æ®åº“ç±»å‹å®‰å…¨ |
| PostgreSQL | å…³ç³»å‹æ•°æ®åº“ï¼ŒACIDæ”¯æŒï¼Œæ€§èƒ½ä¼˜ç§€ | MySQL, MongoDB | ğŸ“Š å¤æ‚æŸ¥è¯¢æ”¯æŒ |
| Edge Runtime | å…¨çƒéƒ¨ç½²ï¼Œä½å»¶è¿Ÿï¼Œæˆæœ¬ä¼˜åŒ– | Node.js Runtime | âš¡ æ¯«ç§’çº§å“åº”æ—¶é—´ |

### 2.2 å‰ç«¯æ¶æ„

#### ğŸ¨ æ¡†æ¶ä¸åº“é€‰å‹è¯¦è§£

**Next.js 15.2.3 App Router æ¶æ„**
```typescript
// åº”ç”¨ç¨‹åºç»“æ„
src/app/
â”œâ”€â”€ layout.tsx              // æ ¹å¸ƒå±€ (æ”¯æŒå¤šè¯­è¨€)
â”œâ”€â”€ page.tsx               // é¦–é¡µ (é™æ€ç”Ÿæˆ)
â”œâ”€â”€ globals.css            // å…¨å±€æ ·å¼
â”œâ”€â”€ (auth)/                // è®¤è¯è·¯ç”±ç»„
â”‚   â”œâ”€â”€ sign-in/
â”‚   â””â”€â”€ sign-up/
â”œâ”€â”€ (dashboard)/           // ç”¨æˆ·é¢æ¿è·¯ç”±ç»„
â”‚   â”œâ”€â”€ profile/
â”‚   â”œâ”€â”€ videos/
â”‚   â””â”€â”€ credits/
â””â”€â”€ api/                   // APIè·¯ç”±
    â”œâ”€â”€ auth/
    â”œâ”€â”€ videos/
    â””â”€â”€ payments/
```

**å¤šå¹³å°éƒ¨ç½²é…ç½®ç­–ç•¥**
```javascript
// next.config.js æ ¸å¿ƒé…ç½®
const nextConfig = {
  // ğŸš€ å¹³å°è‡ªé€‚åº”è¾“å‡º
  output: process.env.RAILWAY_ENVIRONMENT ? 'standalone' : undefined,
  
  // âš¡ Edge Runtime ä¼˜åŒ–
  experimental: {
    forceSwcTransforms: true, // SWCç¼–è¯‘å™¨åŠ é€Ÿ
  },
  
  // ğŸ”§ å¤šå¹³å°å…¼å®¹æ€§
  webpack: (config, { isServer, dev }) => {
    if (!dev) {
      config.optimization.minimize = false; // é¿å…æ„å»ºé—®é¢˜
    }
    return config;
  },
  
  // ğŸ–¼ï¸ å›¾åƒä¼˜åŒ–ç¦ç”¨ï¼ˆæé«˜æ„å»ºç¨³å®šæ€§ï¼‰
  images: { unoptimized: true },
};
```

#### ğŸ“± é¡µé¢æ¶æ„è®¾è®¡

**é¡µé¢åˆ†ç±»ä¸æ¸²æŸ“ç­–ç•¥**
```typescript
// é™æ€é¡µé¢ (Static Generation) - 17ä¸ªé¡µé¢
const staticPages = [
  'about',         // å…³äºæˆ‘ä»¬
  'pricing',       // ä»·æ ¼æ–¹æ¡ˆ  
  'help',          // å¸®åŠ©æ–‡æ¡£
  'privacy',       // éšç§æ”¿ç­–
  'terms',         // ä½¿ç”¨æ¡æ¬¾
  'asmr-types',    // ASMRç±»å‹ä»‹ç»
  'video-showcase', // è§†é¢‘å±•ç¤º
  // ... 10ä¸ªæ›´å¤šé™æ€é¡µé¢
];

// åŠ¨æ€é¡µé¢ (Server-Side Rendering) - 8ä¸ªé¡µé¢  
const dynamicPages = [
  'profile',           // ç”¨æˆ·èµ„æ–™ (éœ€è¦è®¤è¯)
  'payment/success',   // æ”¯ä»˜æˆåŠŸ (éœ€è¦è®¢å•ä¿¡æ¯)
  'payment/cancel',    // æ”¯ä»˜å–æ¶ˆ (éœ€è¦è®¢å•ä¿¡æ¯)
  'credits-recovery',  // ç§¯åˆ†æ¢å¤ (éœ€è¦ç”¨æˆ·æ•°æ®)
  'debug-db',         // æ•°æ®åº“è°ƒè¯• (ç®¡ç†å‘˜)
  'payment-processor', // æ”¯ä»˜å¤„ç†å™¨ (å®æ—¶çŠ¶æ€)
  'test-payment',     // æ”¯ä»˜æµ‹è¯• (å¼€å‘ç¯å¢ƒ)
  'page-en',          // è‹±æ–‡é¡µé¢ (å›½é™…åŒ–)
];
```

**è·¯ç”±é…ç½®ä¸å¯¼èˆªæ¶æ„**
```typescript
// è·¯ç”±ä¸­é—´ä»¶é…ç½®
export const config = {
  matcher: [
    // ğŸ”’ ä¿æŠ¤APIè·¯ç”±
    '/(api|trpc)(.*)',
    // ğŸŒ è·³è¿‡é™æ€èµ„æº
    '/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp|ico|css|js)$).*)',
  ],
};

// å¯¼èˆªç»“æ„
const navigationStructure = {
  public: [
    { path: '/', label: 'é¦–é¡µ' },
    { path: '/asmr-types', label: 'ASMRç±»å‹' },
    { path: '/video-showcase', label: 'è§†é¢‘å±•ç¤º' },
    { path: '/pricing', label: 'ä»·æ ¼' },
  ],
  authenticated: [
    { path: '/profile', label: 'ä¸ªäººä¸­å¿ƒ' },
    { path: '/credits-recovery', label: 'ç§¯åˆ†æ¢å¤' },
  ],
  admin: [
    { path: '/debug-db', label: 'æ•°æ®åº“è°ƒè¯•' },
    { path: '/test-payment', label: 'æ”¯ä»˜æµ‹è¯•' },
  ],
};
```

#### ğŸ§© ç»„ä»¶æ¶æ„è®¾è®¡

**åŸå­åŒ–ç»„ä»¶è®¾è®¡ç³»ç»Ÿ**
```typescript
// ç»„ä»¶å±‚æ¬¡ç»“æ„
src/components/
â”œâ”€â”€ ui/                    // åŸºç¡€UIç»„ä»¶ (åŸå­å±‚)
â”‚   â”œâ”€â”€ Button.tsx
â”‚   â”œâ”€â”€ Input.tsx
â”‚   â”œâ”€â”€ Modal.tsx
â”‚   â””â”€â”€ LoadingSpinner.tsx
â”œâ”€â”€ forms/                 // è¡¨å•ç»„ä»¶ (åˆ†å­å±‚)
â”‚   â”œâ”€â”€ VideoGenerationForm.tsx
â”‚   â”œâ”€â”€ PaymentForm.tsx
â”‚   â””â”€â”€ UserProfileForm.tsx
â”œâ”€â”€ features/              // åŠŸèƒ½ç»„ä»¶ (ç»„ç»‡å±‚)
â”‚   â”œâ”€â”€ VideoGenerator/
â”‚   â”‚   â”œâ”€â”€ VideoForm.tsx
â”‚   â”‚   â”œâ”€â”€ VideoPreview.tsx
â”‚   â”‚   â””â”€â”€ VideoHistory.tsx
â”‚   â”œâ”€â”€ Payment/
â”‚   â”‚   â”œâ”€â”€ CreditPurchase.tsx
â”‚   â”‚   â”œâ”€â”€ PaymentHistory.tsx
â”‚   â”‚   â””â”€â”€ CreemPaymentButton.tsx
â”‚   â””â”€â”€ User/
â”‚       â”œâ”€â”€ ProfileSettings.tsx
â”‚       â”œâ”€â”€ CreditBalance.tsx
â”‚       â””â”€â”€ UserDashboard.tsx
â””â”€â”€ layout/                // å¸ƒå±€ç»„ä»¶ (æ¨¡æ¿å±‚)
    â”œâ”€â”€ Header.tsx
    â”œâ”€â”€ Footer.tsx
    â”œâ”€â”€ Sidebar.tsx
    â””â”€â”€ PageWrapper.tsx
```

**æ ¸å¿ƒç»„ä»¶è¯¦è§£**
```typescript
// 1. ASMRVideoResult.tsx - è§†é¢‘ç»“æœç»„ä»¶
interface VideoResultProps {
  videoData: {
    id: string;
    status: 'processing' | 'completed' | 'failed';
    videoUrl?: string;
    videoUrl1080p?: string;
    thumbnailUrl?: string;
    creditsUsed: number;
  };
}

// 2. CreemPaymentButton.tsx - æ”¯ä»˜æŒ‰é’®ç»„ä»¶  
interface PaymentButtonProps {
  packageType: 'small' | 'medium' | 'large';
  amount: number;
  creditsAmount: number;
  onSuccess: (orderId: string) => void;
  onError: (error: string) => void;
}

// 3. ImageUploader.tsx - å›¾ç‰‡ä¸Šä¼ ç»„ä»¶
interface ImageUploaderProps {
  onImageSelect: (imageData: string) => void;
  maxSize: number; // MB
  acceptedFormats: string[];
  preview?: boolean;
}
```

#### ğŸ”„ çŠ¶æ€ç®¡ç†ç­–ç•¥

**React Hooks çŠ¶æ€ç®¡ç†æ¶æ„**
```typescript
// è‡ªå®šä¹‰ Hooks è®¾è®¡
src/hooks/
â”œâ”€â”€ useCredits.ts          // ç§¯åˆ†ç®¡ç† Hook
â”œâ”€â”€ useVideoGeneration.ts  // è§†é¢‘ç”Ÿæˆ Hook
â”œâ”€â”€ useAuth.ts            // è®¤è¯çŠ¶æ€ Hook
â”œâ”€â”€ usePayment.ts         // æ”¯ä»˜çŠ¶æ€ Hook
â””â”€â”€ useLocalStorage.ts    // æœ¬åœ°å­˜å‚¨ Hook

// useCredits.ts ç¤ºä¾‹
export const useCredits = () => {
  const [credits, setCredits] = useState<{
    total: number;
    used: number;
    remaining: number;
  }>({ total: 0, used: 0, remaining: 0 });
  
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  const fetchCredits = useCallback(async () => {
    setLoading(true);
    try {
      const response = await fetch('/api/credits');
      const data = await response.json();
      setCredits(data);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'è·å–ç§¯åˆ†å¤±è´¥');
    } finally {
      setLoading(false);
    }
  }, []);
  
  return { credits, loading, error, fetchCredits, refetch: fetchCredits };
};
```

**å…¨å±€çŠ¶æ€ç®¡ç†ç­–ç•¥**
```typescript
// Context Providers æ¶æ„
export const AppProviders = ({ children }: { children: React.ReactNode }) => {
  return (
    <ClerkProvider publishableKey={publishableKey}>
      <ThemeProvider>
        <ToastProvider>
          <AnalyticsProvider>
            {children}
          </AnalyticsProvider>
        </ToastProvider>
      </ThemeProvider>
    </ClerkProvider>
  );
};
```

### 2.3 åç«¯æ¶æ„

#### ğŸŒ APIæ¶æ„è®¾è®¡

**RESTful APIè®¾è®¡åŸåˆ™**
```typescript
// API è·¯ç”±å‘½åè§„èŒƒ
/api/v1/{resource}/{action}

// èµ„æºè·¯ç”±ç»“æ„
const apiRoutes = {
  // ç”¨æˆ·ç›¸å…³
  'GET /api/user/profile': 'è·å–ç”¨æˆ·èµ„æ–™',
  'POST /api/user/sync': 'åŒæ­¥ç”¨æˆ·æ•°æ®',
  'DELETE /api/user/delete-account': 'åˆ é™¤ç”¨æˆ·è´¦æˆ·',
  
  // è§†é¢‘ç›¸å…³  
  'POST /api/generate-video': 'ç”Ÿæˆè§†é¢‘',
  'GET /api/video-status/[id]': 'æŸ¥è¯¢è§†é¢‘çŠ¶æ€',
  'GET /api/user/videos': 'è·å–ç”¨æˆ·è§†é¢‘åˆ—è¡¨',
  
  // æ”¯ä»˜ç›¸å…³
  'POST /api/payments/creem-advanced': 'é«˜çº§æ”¯ä»˜API',
  'POST /api/payments/creem': 'ç®€å•æ”¯ä»˜API',
  'GET /api/user/purchases': 'è·å–è´­ä¹°å†å²',
  
  // ç³»ç»Ÿç›¸å…³
  'GET /api/health': 'å¥åº·æ£€æŸ¥',
  'GET /api/credits': 'ç§¯åˆ†æŸ¥è¯¢',
  'POST /api/webhooks/creem': 'Creemæ”¯ä»˜å›è°ƒ',
};
```

**åŒAPIæ¶æ„åˆ›æ–°è®¾è®¡**
```typescript
// åŒAPIæ¶æ„å®ç°é€»è¾‘
export class DualAPIService {
  async processPayment(paymentData: PaymentRequest) {
    try {
      // ğŸš€ Step 1: ä¼˜å…ˆå°è¯•é«˜çº§API
      const advancedResult = await this.callAdvancedAPI(paymentData);
      return {
        success: true,
        data: advancedResult,
        apiUsed: 'advanced'
      };
    } catch (advancedError) {
      console.log('é«˜çº§APIå¤±è´¥ï¼Œå›é€€åˆ°ç®€å•API:', advancedError);
      
      try {
        // ğŸ”„ Step 2: è‡ªåŠ¨å›é€€åˆ°ç®€å•API
        const simpleResult = await this.callSimpleAPI(paymentData);
        return {
          success: true,
          data: simpleResult,
          apiUsed: 'simple'
        };
      } catch (simpleError) {
        // âŒ Step 3: ä¸¤ä¸ªAPIéƒ½å¤±è´¥
        throw new Error('æ”¯ä»˜ç³»ç»Ÿæš‚æ—¶ä¸å¯ç”¨ï¼Œè¯·ç¨åé‡è¯•');
      }
    }
  }
  
  private async callAdvancedAPI(data: PaymentRequest) {
    // Node.js Runtime - æ”¯æŒå®Œæ•´çš„æ•°æ®åº“æ“ä½œ
    // é¢„åˆ›å»ºè®¢å•ï¼Œå…³è”ç”¨æˆ·ï¼Œå®Œæ•´é”™è¯¯å¤„ç†
  }
  
  private async callSimpleAPI(data: PaymentRequest) {
    // Edge Runtime - å¿«é€Ÿå“åº”ï¼Œæ— æ•°æ®åº“ä¾èµ–
    // ç›´æ¥ç”Ÿæˆæ”¯ä»˜é“¾æ¥ï¼Œå…œåº•ä¿éšœ
  }
}
```

#### ğŸ”§ æœåŠ¡å±‚æ¶æ„

**ä¸šåŠ¡é€»è¾‘åˆ†å±‚è®¾è®¡**
```typescript
// æœåŠ¡å±‚æ¶æ„
src/lib/
â”œâ”€â”€ services/              // ä¸šåŠ¡æœåŠ¡å±‚
â”‚   â”œâ”€â”€ VideoService.ts    // è§†é¢‘ç”ŸæˆæœåŠ¡
â”‚   â”œâ”€â”€ PaymentService.ts  // æ”¯ä»˜å¤„ç†æœåŠ¡
â”‚   â”œâ”€â”€ UserService.ts     // ç”¨æˆ·ç®¡ç†æœåŠ¡
â”‚   â”œâ”€â”€ CreditService.ts   // ç§¯åˆ†ç®¡ç†æœåŠ¡
â”‚   â””â”€â”€ NotificationService.ts
â”œâ”€â”€ repositories/          // æ•°æ®è®¿é—®å±‚
â”‚   â”œâ”€â”€ UserRepository.ts
â”‚   â”œâ”€â”€ VideoRepository.ts
â”‚   â””â”€â”€ PaymentRepository.ts
â”œâ”€â”€ utils/                 // å·¥å…·å‡½æ•°å±‚
â”‚   â”œâ”€â”€ api-helpers.ts
â”‚   â”œâ”€â”€ validation.ts
â”‚   â””â”€â”€ encryption.ts
â””â”€â”€ config/               // é…ç½®ç®¡ç†å±‚
    â”œâ”€â”€ database.ts
    â”œâ”€â”€ api-keys.ts
    â””â”€â”€ constants.ts
```

**æœåŠ¡æ¥å£è®¾è®¡ç¤ºä¾‹**
```typescript
// VideoService.ts
export class VideoService {
  constructor(
    private apiKeyPool: APIKeyPool,
    private videoRepository: VideoRepository,
    private creditService: CreditService
  ) {}
  
  async generateVideo(request: VideoGenerationRequest): Promise<VideoResponse> {
    // 1. éªŒè¯ç”¨æˆ·ç§¯åˆ†
    await this.creditService.validateCredits(request.userId, 10);
    
    // 2. è·å–å¯ç”¨çš„APIå¯†é’¥
    const apiKey = await this.apiKeyPool.getAvailableKey();
    
    // 3. è°ƒç”¨Google Veo3 API
    const taskId = await this.callVeo3API(request, apiKey);
    
    // 4. åˆ›å»ºè§†é¢‘è®°å½•
    const video = await this.videoRepository.create({
      userId: request.userId,
      taskId: taskId,
      prompt: request.prompt,
      status: 'processing',
      creditsUsed: 10
    });
    
    // 5. æ‰£é™¤ç§¯åˆ†
    await this.creditService.deductCredits(request.userId, 10);
    
    return { videoId: video.id, taskId: taskId };
  }
}
```

#### ğŸ›¡ï¸ ä¸­é—´ä»¶ç³»ç»Ÿ

**ä¸­é—´ä»¶æ¶æ„è®¾è®¡**
```typescript
// ä¸­é—´ä»¶å †æ ˆ
const middlewareStack = [
  clerkMiddleware(),           // è®¤è¯ä¸­é—´ä»¶
  corsMiddleware(),           // CORSå¤„ç†
  rateLimitMiddleware(),      // é€Ÿç‡é™åˆ¶
  validationMiddleware(),     // è¯·æ±‚éªŒè¯
  loggingMiddleware(),        // æ—¥å¿—è®°å½•
  errorHandlingMiddleware(),  // é”™è¯¯å¤„ç†
];

// è®¤è¯ä¸­é—´ä»¶é…ç½®
export const authMiddleware = {
  matcher: [
    '/(api|trpc)(.*)',  // ä¿æŠ¤æ‰€æœ‰APIè·¯ç”±
    '/profile',         // ä¿æŠ¤ç”¨æˆ·é¡µé¢
    '/credits-recovery', // ä¿æŠ¤ç§¯åˆ†é¡µé¢
  ],
  publicRoutes: [
    '/',                // é¦–é¡µå…¬å¼€
    '/api/health',      // å¥åº·æ£€æŸ¥å…¬å¼€
    '/api/webhook/(.*)', // Webhookå…¬å¼€
  ],
};
```

---

## ğŸ’¾ ç¬¬ä¸‰éƒ¨åˆ†ï¼šæ•°æ®æ¶æ„è®¾è®¡

### 3.1 æ•°æ®åº“æ¶æ„

#### ğŸ—„ï¸ æ•°æ®æ¨¡å‹è®¾è®¡

**å®ä½“å…³ç³»å›¾ (ERD)**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    1:N    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    N:1    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      User       â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚    Purchase     â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚   PaymentType   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤           â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤           â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ id (PK)         â”‚           â”‚ id (PK)         â”‚           â”‚ starter         â”‚
â”‚ clerkUserId     â”‚           â”‚ userId (FK)     â”‚           â”‚ standard        â”‚
â”‚ email           â”‚           â”‚ packageType     â”‚           â”‚ premium         â”‚
â”‚ googleFullName  â”‚           â”‚ amount          â”‚           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚ totalCredits    â”‚           â”‚ creditsAdded    â”‚
â”‚ usedCredits     â”‚           â”‚ orderId         â”‚
â”‚ isActive        â”‚           â”‚ status          â”‚
â”‚ lastLoginAt     â”‚           â”‚ createdAt       â”‚
â”‚ createdAt       â”‚           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚ 1:N                         
         â–¼                             
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      Video      â”‚           â”‚    AuditLog     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤           â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ id (PK)         â”‚           â”‚ id (PK)         â”‚
â”‚ userId (FK)     â”‚           â”‚ userId (FK)     â”‚
â”‚ taskId          â”‚           â”‚ action          â”‚
â”‚ prompt          â”‚           â”‚ details (JSON)  â”‚
â”‚ status          â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚ ipAddress       â”‚
â”‚ videoUrl        â”‚           â”‚ userAgent       â”‚
â”‚ videoUrl1080p   â”‚           â”‚ createdAt       â”‚
â”‚ thumbnailUrl    â”‚           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚ creditsUsed     â”‚           
â”‚ createdAt       â”‚           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚   AdminLog      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤           
â”‚ id (PK)         â”‚           
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚ userId (FK)     â”‚
â”‚    Settings     â”‚           â”‚ adminEmail      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤           â”‚ action          â”‚
â”‚ id (PK)         â”‚           â”‚ oldValues       â”‚
â”‚ key             â”‚           â”‚ newValues       â”‚
â”‚ value           â”‚           â”‚ reason          â”‚
â”‚ createdAt       â”‚           â”‚ createdAt       â”‚
â”‚ updatedAt       â”‚           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           
```

**æ•°æ®è¡¨ç»“æ„è¯¦è§£**

**1. User è¡¨ (ç”¨æˆ·ä¸»è¡¨)**
```sql
CREATE TABLE users (
  id              TEXT PRIMARY KEY DEFAULT gen_random_uuid(),
  clerkUserId     TEXT UNIQUE NOT NULL,           -- Clerkè®¤è¯ID
  email           TEXT UNIQUE NOT NULL,            -- ç”¨æˆ·é‚®ç®±
  googleFullName  TEXT,                           -- Googleç”¨æˆ·å
  googleImageUrl  TEXT,                           -- Googleå¤´åƒURL
  customDisplayName TEXT,                         -- è‡ªå®šä¹‰æ˜¾ç¤ºå
  totalCredits    INTEGER DEFAULT 8,              -- æ€»ç§¯åˆ†æ•°
  usedCredits     INTEGER DEFAULT 0,              -- å·²ä½¿ç”¨ç§¯åˆ†
  isActive        BOOLEAN DEFAULT true,           -- è´¦æˆ·çŠ¶æ€
  createdAt       TIMESTAMP DEFAULT NOW(),        -- åˆ›å»ºæ—¶é—´
  updatedAt       TIMESTAMP DEFAULT NOW(),        -- æ›´æ–°æ—¶é—´
  lastLoginAt     TIMESTAMP DEFAULT NOW()         -- æœ€åç™»å½•æ—¶é—´
);

-- ç´¢å¼•ä¼˜åŒ–
CREATE INDEX idx_users_clerk_id ON users(clerkUserId);
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_active ON users(isActive) WHERE isActive = true;
```

**2. Purchase è¡¨ (è´­ä¹°è®°å½•è¡¨)**
```sql
CREATE TABLE purchases (
  id            TEXT PRIMARY KEY DEFAULT gen_random_uuid(),
  userId        TEXT REFERENCES users(id) ON DELETE CASCADE,
  packageType   TEXT NOT NULL,                   -- starter/standard/premium
  packageName   TEXT NOT NULL,                   -- å¥—é¤æ˜¾ç¤ºåç§°
  amount        DECIMAL(10,2) NOT NULL,          -- æ”¯ä»˜é‡‘é¢
  currency      TEXT DEFAULT 'USD',              -- æ”¯ä»˜å¸ç§
  creditsAdded  INTEGER NOT NULL,                -- æ·»åŠ çš„ç§¯åˆ†æ•°
  orderId       TEXT UNIQUE,                     -- Creemè®¢å•ID
  customerId    TEXT,                            -- å®¢æˆ·ID
  provider      TEXT DEFAULT 'creem',            -- æ”¯ä»˜æä¾›å•†
  status        TEXT DEFAULT 'completed',        -- æ”¯ä»˜çŠ¶æ€
  paymentEmail  TEXT,                            -- æ”¯ä»˜é‚®ç®±
  createdAt     TIMESTAMP DEFAULT NOW(),         -- åˆ›å»ºæ—¶é—´
  completedAt   TIMESTAMP DEFAULT NOW()          -- å®Œæˆæ—¶é—´
);

-- ç´¢å¼•ä¼˜åŒ–
CREATE INDEX idx_purchases_user_id ON purchases(userId);
CREATE INDEX idx_purchases_order_id ON purchases(orderId);
CREATE INDEX idx_purchases_status ON purchases(status);
CREATE INDEX idx_purchases_created_at ON purchases(createdAt DESC);
```

**3. Video è¡¨ (è§†é¢‘è®°å½•è¡¨)**
```sql
CREATE TABLE videos (
  id            TEXT PRIMARY KEY DEFAULT gen_random_uuid(),
  userId        TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  taskId        TEXT,                             -- Veo3 APIä»»åŠ¡ID
  title         TEXT NOT NULL,                    -- è§†é¢‘æ ‡é¢˜
  type          TEXT NOT NULL,                    -- ASMRç±»å‹
  prompt        TEXT NOT NULL,                    -- ç”Ÿæˆæç¤ºè¯
  status        TEXT DEFAULT 'processing',        -- processing/completed/failed
  videoUrl      TEXT,                            -- æ ‡å‡†è§†é¢‘URL
  videoUrl1080p TEXT,                            -- é«˜æ¸…è§†é¢‘URL
  thumbnailUrl  TEXT,                            -- ç¼©ç•¥å›¾URL
  creditsUsed   INTEGER DEFAULT 10,              -- æ¶ˆè€—ç§¯åˆ†æ•°
  createdAt     TIMESTAMP DEFAULT NOW(),         -- åˆ›å»ºæ—¶é—´
  updatedAt     TIMESTAMP DEFAULT NOW(),         -- æ›´æ–°æ—¶é—´
  completedAt   TIMESTAMP                        -- å®Œæˆæ—¶é—´
);

-- ç´¢å¼•ä¼˜åŒ–
CREATE INDEX idx_videos_user_id ON videos(userId);
CREATE INDEX idx_videos_task_id ON videos(taskId);
CREATE INDEX idx_videos_status ON videos(status);
CREATE INDEX idx_videos_created_at ON videos(createdAt DESC);
```

#### ğŸ“Š æ•°æ®è®¿é—®å±‚è®¾è®¡

**Prisma ORM é…ç½®ç­–ç•¥**
```typescript
// prisma/schema.prisma æ ¸å¿ƒé…ç½®
generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-1.1.x"] // å¤šå¹³å°æ”¯æŒ
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL") // Railway PostgreSQL
}

// å…³ç³»é…ç½®ä¼˜åŒ–
model User {
  // ä¸»é”®å’Œå¤–é”®ä¼˜åŒ–
  @@map("users")
  @@index([clerkUserId])
  @@index([email])
  @@index([isActive])
  
  // å…³è”å…³ç³»
  purchases Purchase[]
  videos    Video[]
  auditLogs AuditLog[]
  adminLogs AdminLog[]
}
```

**æŸ¥è¯¢ä¼˜åŒ–ç­–ç•¥**
```typescript
// æ•°æ®è®¿é—®æ¨¡å¼ä¼˜åŒ–
export class UserRepository {
  // ğŸš€ é«˜é¢‘æŸ¥è¯¢ä¼˜åŒ– - ç”¨æˆ·ç§¯åˆ†ä¿¡æ¯
  async getUserCredits(clerkUserId: string) {
    return await db.user.findUnique({
      where: { clerkUserId },
      select: {
        id: true,
        totalCredits: true,
        usedCredits: true,
        // è®¡ç®—å­—æ®µ
        _count: {
          select: { videos: true }
        }
      }
    });
  }

  // ğŸ”„ åŒé‡åŒ¹é…ç­–ç•¥ - ç”¨æˆ·åŒæ­¥ä¼˜åŒ–
  async findUserWithFallback(clerkUserId: string, email?: string) {
    // ä¼˜å…ˆé€šè¿‡Clerk IDæŸ¥æ‰¾
    let user = await db.user.findUnique({
      where: { clerkUserId }
    });

    // å¤‡ç”¨ï¼šé€šè¿‡é‚®ç®±æŸ¥æ‰¾å¹¶æ›´æ–°Clerk ID
    if (!user && email) {
      user = await db.user.findUnique({
        where: { email }
      });
      
      if (user) {
        // åŸå­æ›´æ–°æ“ä½œ
        user = await db.user.update({
          where: { id: user.id },
          data: { 
            clerkUserId,
            lastLoginAt: new Date()
          }
        });
      }
    }

    return user;
  }

  // ğŸ“ˆ æ‰¹é‡æŸ¥è¯¢ä¼˜åŒ– - ç”¨æˆ·è§†é¢‘å†å²
  async getUserVideosWithPagination(userId: string, page = 1, limit = 10) {
    const skip = (page - 1) * limit;
    
    const [videos, total] = await Promise.all([
      db.video.findMany({
        where: { userId },
        orderBy: { createdAt: 'desc' },
        skip,
        take: limit,
        select: {
          id: true,
          title: true,
          status: true,
          videoUrl: true,
          thumbnailUrl: true,
          creditsUsed: true,
          createdAt: true
        }
      }),
      db.video.count({
        where: { userId }
      })
    ]);

    return {
      videos,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit),
        hasNext: page * limit < total,
        hasPrev: page > 1
      }
    };
  }
}
```

#### ğŸ”„ æ•°æ®è¿ç§»ç­–ç•¥

**ç‰ˆæœ¬æ§åˆ¶æœºåˆ¶**
```typescript
// è¿ç§»ç‰ˆæœ¬ç®¡ç†ç­–ç•¥
const migrationVersions = {
  'v1.0.0': 'initial-schema',          // åˆå§‹æ•°æ®åº“ç»“æ„
  'v1.1.0': 'add-video-1080p-field',   // æ·»åŠ é«˜æ¸…è§†é¢‘å­—æ®µ
  'v1.2.0': 'optimize-indexes',        // ç´¢å¼•ä¼˜åŒ–
  'v1.3.0': 'add-audit-logs',          // æ·»åŠ å®¡è®¡æ—¥å¿—
  'v2.0.0': 'simplify-user-model',     // ç®€åŒ–ç”¨æˆ·æ¨¡å‹
};

// è¿ç§»è„šæœ¬ç¤ºä¾‹
-- Migration: 20250127_add_video_1080p_field
ALTER TABLE videos ADD COLUMN videoUrl1080p TEXT;
CREATE INDEX idx_videos_1080p ON videos(videoUrl1080p) WHERE videoUrl1080p IS NOT NULL;

-- Migration: 20250127_optimize_credit_queries  
CREATE INDEX idx_users_credits ON users(totalCredits, usedCredits);
CREATE INDEX idx_videos_credits_used ON videos(creditsUsed);
```

### 3.2 æ•°æ®æµæ¶æ„

#### ğŸŒŠ æ•°æ®ç”Ÿå‘½å‘¨æœŸç®¡ç†

**ç”¨æˆ·æ•°æ®ç”Ÿå‘½å‘¨æœŸ**
```mermaid
graph TD
    A[ç”¨æˆ·æ³¨å†Œ] --> B[Clerkè®¤è¯]
    B --> C[åˆ›å»ºUserè®°å½•]
    C --> D[åˆ†é…åˆå§‹ç§¯åˆ†8åˆ†]
    D --> E[è®°å½•AuditLog]
    E --> F[ç”¨æˆ·æ¿€æ´»]
    
    F --> G[æ—¥å¸¸ä½¿ç”¨]
    G --> H[ç”Ÿæˆè§†é¢‘]
    H --> I[æ‰£é™¤ç§¯åˆ†10åˆ†]
    I --> J[æ›´æ–°usedCredits]
    J --> K[åˆ›å»ºVideoè®°å½•]
    
    G --> L[è´­ä¹°ç§¯åˆ†åŒ…]
    L --> M[Creemæ”¯ä»˜]
    M --> N[Webhookå›è°ƒ]
    N --> O[æ›´æ–°totalCredits]
    O --> P[åˆ›å»ºPurchaseè®°å½•]
    
    K --> Q[å®šæœŸæ¸…ç†]
    P --> Q
    Q --> R[æ•°æ®å½’æ¡£]
    R --> S[é•¿æœŸå­˜å‚¨]
```

**ç§¯åˆ†ç³»ç»Ÿæ•°æ®æµ**
```typescript
// ç§¯åˆ†ç³»ç»Ÿæ•°æ®æµè®¾è®¡
export class CreditFlowService {
  // ğŸ’° ç§¯åˆ†æ¶ˆè´¹æµç¨‹
  async consumeCredits(userId: string, amount: number, reason: string) {
    return await db.$transaction(async (tx) => {
      // 1. éªŒè¯ç§¯åˆ†ä½™é¢
      const user = await tx.user.findUnique({
        where: { id: userId },
        select: { totalCredits: true, usedCredits: true }
      });

      if (!user || (user.totalCredits - user.usedCredits) < amount) {
        throw new Error('ç§¯åˆ†ä¸è¶³');
      }

      // 2. æ›´æ–°å·²ä½¿ç”¨ç§¯åˆ†
      const updatedUser = await tx.user.update({
        where: { id: userId },
        data: { usedCredits: user.usedCredits + amount }
      });

      // 3. è®°å½•å®¡è®¡æ—¥å¿—
      await tx.auditLog.create({
        data: {
          userId,
          action: 'credits_consumed',
          details: {
            amount,
            reason,
            beforeBalance: user.totalCredits - user.usedCredits,
            afterBalance: user.totalCredits - updatedUser.usedCredits
          }
        }
      });

      return updatedUser;
    });
  }

  // ğŸ’ ç§¯åˆ†å……å€¼æµç¨‹
  async addCredits(userId: string, amount: number, purchaseId: string) {
    return await db.$transaction(async (tx) => {
      // 1. æ›´æ–°æ€»ç§¯åˆ†
      const updatedUser = await tx.user.update({
        where: { id: userId },
        data: { totalCredits: { increment: amount } }
      });

      // 2. æ›´æ–°è´­ä¹°è®°å½•çŠ¶æ€
      await tx.purchase.update({
        where: { id: purchaseId },
        data: { status: 'completed' }
      });

      // 3. è®°å½•å®¡è®¡æ—¥å¿—
      await tx.auditLog.create({
        data: {
          userId,
          action: 'credits_added',
          details: {
            amount,
            purchaseId,
            newTotalCredits: updatedUser.totalCredits
          }
        }
      });

      return updatedUser;
    });
  }
}
```

#### ğŸ”„ æ•°æ®åŒæ­¥æœºåˆ¶

**ç”¨æˆ·æ•°æ®åŒæ­¥ç­–ç•¥**
```typescript
// å¤šæºæ•°æ®åŒæ­¥æœºåˆ¶
export class DataSyncService {
  // ğŸ”„ Clerkç”¨æˆ·æ•°æ®åŒæ­¥
  async syncUserFromClerk(clerkUserId: string) {
    try {
      // 1. è·å–Clerkç”¨æˆ·ä¿¡æ¯
      const clerkUser = await currentUser();
      if (!clerkUser) throw new Error('Clerkç”¨æˆ·ä¸å­˜åœ¨');

      // 2. åŒæ­¥åˆ°æœ¬åœ°æ•°æ®åº“
      const syncedUser = await db.user.upsert({
        where: { clerkUserId },
        update: {
          googleFullName: clerkUser.fullName,
          lastLoginAt: new Date()
        },
        create: {
          clerkUserId,
          email: clerkUser.primaryEmailAddress?.emailAddress || '',
          googleFullName: clerkUser.fullName,
          totalCredits: 8, // åˆå§‹ç§¯åˆ†
          usedCredits: 0,
          isActive: true,
          googleVerifiedAt: new Date(),
          lastLoginAt: new Date()
        }
      });

      // 3. è®°å½•åŒæ­¥æ—¥å¿—
      await this.logUserSync(syncedUser.id, clerkUser);

      return syncedUser;
    } catch (error) {
      console.error('ç”¨æˆ·åŒæ­¥å¤±è´¥:', error);
      throw error;
    }
  }

  // ğŸ“Š Veo3 APIçŠ¶æ€åŒæ­¥
  async syncVideoStatus(taskId: string) {
    try {
      // 1. è°ƒç”¨Veo3 APIæŸ¥è¯¢çŠ¶æ€
      const apiResponse = await this.queryVeo3Status(taskId);
      
      // 2. æ›´æ–°æœ¬åœ°è§†é¢‘è®°å½•
      const updatedVideo = await db.video.update({
        where: { taskId },
        data: {
          status: apiResponse.status,
          videoUrl: apiResponse.video_url,
          videoUrl1080p: apiResponse.video_url_1080p,
          thumbnailUrl: apiResponse.thumbnail_url,
          completedAt: apiResponse.status === 'completed' ? new Date() : null
        }
      });

      return updatedVideo;
    } catch (error) {
      console.error('è§†é¢‘çŠ¶æ€åŒæ­¥å¤±è´¥:', error);
      throw error;
    }
  }
}
```

### 3.3 ç¼“å­˜å±‚è®¾è®¡

#### âš¡ ç¼“å­˜ç­–ç•¥æ¶æ„

**å¤šå±‚ç¼“å­˜è®¾è®¡**
```typescript
// ç¼“å­˜å±‚æ¶æ„è®¾è®¡
export class CacheService {
  private memoryCache = new Map(); // å†…å­˜ç¼“å­˜
  private redisTTL = {
    userCredits: 300,    // 5åˆ†é’Ÿ
    videoStatus: 60,     // 1åˆ†é’Ÿ
    apiKeys: 3600,       // 1å°æ—¶
    systemConfig: 1800   // 30åˆ†é’Ÿ
  };

  // ğŸš€ ç”¨æˆ·ç§¯åˆ†ç¼“å­˜
  async getUserCreditsWithCache(clerkUserId: string) {
    const cacheKey = `credits:${clerkUserId}`;
    
    // 1. å°è¯•ä»å†…å­˜ç¼“å­˜è·å–
    if (this.memoryCache.has(cacheKey)) {
      const cached = this.memoryCache.get(cacheKey);
      if (Date.now() - cached.timestamp < 60000) { // 1åˆ†é’Ÿæœ‰æ•ˆ
        return cached.data;
      }
    }

    // 2. ä»æ•°æ®åº“è·å–æœ€æ–°æ•°æ®
    const user = await db.user.findUnique({
      where: { clerkUserId },
      select: {
        totalCredits: true,
        usedCredits: true,
        _count: { select: { videos: true } }
      }
    });

    if (user) {
      const creditsData = {
        totalCredits: user.totalCredits,
        usedCredits: user.usedCredits,
        remainingCredits: user.totalCredits - user.usedCredits,
        videosCount: user._count.videos
      };

      // 3. æ›´æ–°å†…å­˜ç¼“å­˜
      this.memoryCache.set(cacheKey, {
        data: creditsData,
        timestamp: Date.now()
      });

      return creditsData;
    }

    return null;
  }

  // ğŸ”„ ç¼“å­˜å¤±æ•ˆç®¡ç†
  async invalidateUserCache(clerkUserId: string) {
    const cacheKey = `credits:${clerkUserId}`;
    this.memoryCache.delete(cacheKey);
    console.log(`ğŸ—‘ï¸ ç¼“å­˜å·²å¤±æ•ˆ: ${cacheKey}`);
  }

  // ğŸ“Š æ‰¹é‡ç¼“å­˜é¢„çƒ­
  async warmupCache() {
    try {
      // é¢„çƒ­æ´»è·ƒç”¨æˆ·ç§¯åˆ†ç¼“å­˜
      const activeUsers = await db.user.findMany({
        where: { 
          isActive: true,
          lastLoginAt: { gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000) }
        },
        select: { clerkUserId: true },
        take: 100
      });

      await Promise.all(
        activeUsers.map(user => this.getUserCreditsWithCache(user.clerkUserId))
      );

      console.log(`ğŸ”¥ ç¼“å­˜é¢„çƒ­å®Œæˆï¼Œå·²é¢„çƒ­ ${activeUsers.length} ä¸ªç”¨æˆ·`);
    } catch (error) {
      console.error('ç¼“å­˜é¢„çƒ­å¤±è´¥:', error);
    }
  }
}
```

#### ğŸ”‘ APIå¯†é’¥æ± ç¼“å­˜

**æ™ºèƒ½å¯†é’¥è½®è¯¢ç¼“å­˜**
```typescript
// APIå¯†é’¥æ± çŠ¶æ€ç¼“å­˜
export class ApiKeyPoolCache {
  private keyStatus = new Map();
  private readonly maxErrorCount = 3;
  private readonly blockDuration = 5 * 60 * 1000; // 5åˆ†é’Ÿ

  // ğŸ”‘ è·å–å¯ç”¨å¯†é’¥ï¼ˆå¸¦ç¼“å­˜ä¼˜åŒ–ï¼‰
  getAvailableKeyWithCache(): string {
    // 1. æ¸…ç†è¿‡æœŸçš„å°ç¦çŠ¶æ€
    this.cleanupExpiredBlocks();

    // 2. è·å–å¯ç”¨å¯†é’¥åˆ—è¡¨
    const availableKeys = Array.from(this.keyStatus.entries())
      .filter(([key, status]) => !status.isBlocked)
      .sort((a, b) => a[1].lastUsed - b[1].lastUsed); // æŒ‰ä½¿ç”¨æ—¶é—´æ’åº

    if (availableKeys.length === 0) {
      console.warn('âš ï¸ æ‰€æœ‰å¯†é’¥éƒ½è¢«ä¸´æ—¶å°ç¦ï¼Œä½¿ç”¨å¤‡ç”¨å¯†é’¥');
      return this.getFallbackKey();
    }

    // 3. é€‰æ‹©æœ€ä¹…æœªä½¿ç”¨çš„å¯†é’¥
    const [selectedKey] = availableKeys[0];
    this.updateKeyUsage(selectedKey);
    
    return selectedKey;
  }

  // ğŸ“Š å¯†é’¥çŠ¶æ€ç»Ÿè®¡ç¼“å­˜
  getPoolStatusCache() {
    const now = Date.now();
    const totalKeys = this.keyStatus.size;
    const availableKeys = Array.from(this.keyStatus.values())
      .filter(status => !status.isBlocked).length;
    
    return {
      totalKeys,
      availableKeys,
      blockedKeys: totalKeys - availableKeys,
      healthScore: Math.round((availableKeys / totalKeys) * 100),
      lastUpdated: now
    };
  }
}
```

### 3.4 æ•°æ®ä¸€è‡´æ€§ä¿è¯

#### ğŸ”’ äº‹åŠ¡ç®¡ç†ç­–ç•¥

**ACIDäº‹åŠ¡è®¾è®¡**
```typescript
// å…³é”®ä¸šåŠ¡äº‹åŠ¡è®¾è®¡
export class TransactionService {
  // ğŸ’³ æ”¯ä»˜å®Œæˆäº‹åŠ¡
  async processPaymentCompletion(orderId: string, webhookData: any) {
    return await db.$transaction(async (tx) => {
      // 1. éªŒè¯è®¢å•å­˜åœ¨ä¸”æœªå¤„ç†
      const purchase = await tx.purchase.findUnique({
        where: { orderId },
        include: { user: true }
      });

      if (!purchase || purchase.status === 'completed') {
        throw new Error('è®¢å•ä¸å­˜åœ¨æˆ–å·²å¤„ç†');
      }

      // 2. æ›´æ–°ç”¨æˆ·æ€»ç§¯åˆ†
      await tx.user.update({
        where: { id: purchase.userId! },
        data: { totalCredits: { increment: purchase.creditsAdded } }
      });

      // 3. æ›´æ–°è´­ä¹°è®°å½•çŠ¶æ€
      await tx.purchase.update({
        where: { id: purchase.id },
        data: { 
          status: 'completed',
          completedAt: new Date()
        }
      });

      // 4. è®°å½•å®¡è®¡æ—¥å¿—
      await tx.auditLog.create({
        data: {
          userId: purchase.userId,
          action: 'payment_completed',
          details: {
            orderId,
            amount: purchase.amount,
            creditsAdded: purchase.creditsAdded,
            webhookData
          }
        }
      });

      return purchase;
    }, {
      maxWait: 5000,    // æœ€å¤§ç­‰å¾…5ç§’
      timeout: 10000,   // è¶…æ—¶10ç§’
      isolationLevel: 'Serializable' // æœ€é«˜éš”ç¦»çº§åˆ«
    });
  }

  // ğŸ¬ è§†é¢‘ç”Ÿæˆäº‹åŠ¡
  async createVideoWithCreditDeduction(userId: string, videoData: any) {
    return await db.$transaction(async (tx) => {
      // 1. éªŒè¯ç”¨æˆ·ç§¯åˆ†
      const user = await tx.user.findUnique({
        where: { id: userId },
        select: { totalCredits: true, usedCredits: true }
      });

      const remainingCredits = user!.totalCredits - user!.usedCredits;
      if (remainingCredits < 10) {
        throw new Error('ç§¯åˆ†ä¸è¶³ï¼Œæ— æ³•ç”Ÿæˆè§†é¢‘');
      }

      // 2. åˆ›å»ºè§†é¢‘è®°å½•
      const video = await tx.video.create({
        data: {
          ...videoData,
          userId,
          creditsUsed: 10,
          status: 'processing'
        }
      });

      // 3. æ‰£é™¤ç§¯åˆ†
      await tx.user.update({
        where: { id: userId },
        data: { usedCredits: { increment: 10 } }
      });

      // 4. è®°å½•æ“ä½œæ—¥å¿—
      await tx.auditLog.create({
        data: {
          userId,
          action: 'video_created',
          details: {
            videoId: video.id,
            creditsUsed: 10,
            remainingCredits: remainingCredits - 10
          }
        }
      });

      return video;
    });
  }
}
```

#### ğŸ”„ æ•°æ®å¤‡ä»½ä¸æ¢å¤

**è‡ªåŠ¨å¤‡ä»½ç­–ç•¥**
```typescript
// æ•°æ®å¤‡ä»½ä¸æ¢å¤æœåŠ¡
export class BackupService {
  // ğŸ“¦ æ¯æ—¥è‡ªåŠ¨å¤‡ä»½
  async performDailyBackup() {
    const timestamp = new Date().toISOString().split('T')[0];
    const backupName = `backup_${timestamp}`;
    
    try {
      // 1. æ•°æ®åº“å®Œæ•´å¤‡ä»½
      await this.createDatabaseBackup(backupName);
      
      // 2. å…³é”®æ•°æ®å•ç‹¬å¤‡ä»½
      await this.backupCriticalData(backupName);
      
      // 3. æ¸…ç†æ—§å¤‡ä»½
      await this.cleanupOldBackups();
      
      console.log(`âœ… æ¯æ—¥å¤‡ä»½å®Œæˆ: ${backupName}`);
    } catch (error) {
      console.error('å¤‡ä»½å¤±è´¥:', error);
      // å‘é€å‘Šè­¦é€šçŸ¥
      await this.sendBackupFailureAlert(error);
    }
  }

  // ğŸš¨ ç´§æ€¥æ•°æ®æ¢å¤
  async emergencyRestore(backupName: string) {
    console.log(`ğŸš¨ å¼€å§‹ç´§æ€¥æ•°æ®æ¢å¤: ${backupName}`);
    
    try {
      // 1. éªŒè¯å¤‡ä»½å®Œæ•´æ€§
      await this.verifyBackupIntegrity(backupName);
      
      // 2. åˆ›å»ºæ¢å¤å‰å¿«ç…§
      await this.createPreRestoreSnapshot();
      
      // 3. æ‰§è¡Œæ•°æ®æ¢å¤
      await this.restoreFromBackup(backupName);
      
      // 4. éªŒè¯æ¢å¤ç»“æœ
      await this.verifyRestoreSuccess();
      
      console.log(`âœ… æ•°æ®æ¢å¤å®Œæˆ: ${backupName}`);
    } catch (error) {
      console.error('æ•°æ®æ¢å¤å¤±è´¥:', error);
      throw error;
    }
  }
}
```

---

## ğŸ” ç¬¬å››éƒ¨åˆ†ï¼šå®‰å…¨æ¶æ„

### 4.1 èº«ä»½è®¤è¯ä¸æˆæƒ

#### ğŸ›¡ï¸ Clerk è®¤è¯ç³»ç»Ÿé›†æˆ

**è®¤è¯æ¶æ„è®¾è®¡**
```typescript
// è®¤è¯ç³»ç»Ÿæ¶æ„
export const AuthenticationArchitecture = {
  // ğŸ” è®¤è¯æä¾›å•†ï¼šClerk
  provider: 'Clerk',
  version: '6.22.0',
  
  // ğŸŒ å¤šå¹³å°è®¤è¯æ”¯æŒ
  platforms: {
    web: 'NextJS + Clerk SDK',
    mobile: 'Clerk Mobile SDK (æœªæ¥æ”¯æŒ)',
    api: 'JWT TokenéªŒè¯'
  },
  
  // ğŸ”‘ è®¤è¯æ–¹å¼
  authMethods: {
    google: {
      enabled: true,
      provider: 'Google OAuth 2.0',
      scope: ['profile', 'email'],
      userInfo: ['name', 'email', 'avatar']
    },
    email: {
      enabled: true,
      verification: 'required',
      passwordPolicy: 'complex'
    },
    phone: {
      enabled: false, // æœªæ¥åŠŸèƒ½
      sms: 'international'
    }
  }
};
```

**JWT Token ç®¡ç†ç­–ç•¥**
```typescript
// JWTä»¤ç‰Œç”Ÿå‘½å‘¨æœŸç®¡ç†
export class JWTTokenManager {
  private readonly tokenConfig = {
    accessTokenTTL: 3600,      // 1å°æ—¶
    refreshTokenTTL: 604800,   // 7å¤©
    maxSessionAge: 2592000,    // 30å¤©
    algorithm: 'RS256'
  };

  // ğŸ”„ ä»¤ç‰ŒéªŒè¯ä¸­é—´ä»¶
  async validateToken(request: NextRequest): Promise<AuthResult> {
    try {
      const { userId, sessionId } = await auth();
      
      if (!userId) {
        return {
          isValid: false,
          error: 'No active session'
        };
      }

      // æ£€æŸ¥ä¼šè¯æœ‰æ•ˆæ€§
      const session = await clerkClient.sessions.getSession(sessionId!);
      if (session.status !== 'active') {
        return {
          isValid: false,
          error: 'Session expired'
        };
      }

      return {
        isValid: true,
        userId,
        sessionId,
        permissions: await this.getUserPermissions(userId)
      };
    } catch (error) {
      console.error('Token validation failed:', error);
      return {
        isValid: false,
        error: 'Token validation failed'
      };
    }
  }

  // ğŸ” è·å–ç”¨æˆ·æƒé™
  private async getUserPermissions(userId: string): Promise<string[]> {
    const user = await db.user.findUnique({
      where: { clerkUserId: userId },
      select: { 
        isActive: true,
        totalCredits: true,
        usedCredits: true
      }
    });

    const permissions = ['basic:access'];
    
    if (user?.isActive) {
      permissions.push('video:generate');
    }
    
    if ((user?.totalCredits || 0) - (user?.usedCredits || 0) >= 10) {
      permissions.push('video:premium');
    }

    return permissions;
  }
}
```

#### ğŸšª ä¼šè¯ç®¡ç†ç­–ç•¥

**ä¼šè¯ç”Ÿå‘½å‘¨æœŸç®¡ç†**
```typescript
// ä¼šè¯ç®¡ç†æœåŠ¡
export class SessionManagementService {
  // ğŸ“Š ä¼šè¯çŠ¶æ€è·Ÿè¸ª
  async trackUserSession(clerkUserId: string, sessionData: any) {
    try {
      await db.user.update({
        where: { clerkUserId },
        data: { 
          lastLoginAt: new Date(),
        }
      });

      // è®°å½•ä¼šè¯å®¡è®¡æ—¥å¿—
      await db.auditLog.create({
        data: {
          userId: await this.getUserId(clerkUserId),
          action: 'session_start',
          details: {
            sessionId: sessionData.sessionId,
            userAgent: sessionData.userAgent,
            ipAddress: sessionData.ipAddress,
            loginMethod: sessionData.method
          },
          ipAddress: sessionData.ipAddress,
          userAgent: sessionData.userAgent
        }
      });

      console.log(`âœ… ç”¨æˆ· ${clerkUserId} ä¼šè¯å·²è®°å½•`);
    } catch (error) {
      console.error('ä¼šè¯è·Ÿè¸ªå¤±è´¥:', error);
    }
  }

  // ğŸ”š ä¼šè¯æ¸…ç†
  async cleanupExpiredSessions() {
    const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
    
    try {
      const expiredUsers = await db.user.findMany({
        where: {
          lastLoginAt: { lt: thirtyDaysAgo },
          isActive: true
        },
        select: { id: true, clerkUserId: true }
      });

      for (const user of expiredUsers) {
        // è®°å½•ä¼šè¯è¿‡æœŸæ—¥å¿—
        await db.auditLog.create({
          data: {
            userId: user.id,
            action: 'session_expired',
            details: {
              reason: 'inactive_30_days',
              lastLogin: user.lastLoginAt
            }
          }
        });
      }

      console.log(`ğŸ§¹ æ¸…ç†äº† ${expiredUsers.length} ä¸ªè¿‡æœŸä¼šè¯`);
    } catch (error) {
      console.error('ä¼šè¯æ¸…ç†å¤±è´¥:', error);
    }
  }
}
```

### 4.2 APIå®‰å…¨

#### ğŸ”‘ APIå¯†é’¥ç®¡ç†

**å¤šå±‚çº§å¯†é’¥ç®¡ç†ç³»ç»Ÿ**
```typescript
// APIå¯†é’¥å®‰å…¨ç®¡ç†
export class APIKeySecurityManager {
  private readonly keyConfig = {
    rotation: {
      enabled: true,
      interval: 30 * 24 * 60 * 60 * 1000, // 30å¤©
      overlap: 7 * 24 * 60 * 60 * 1000    // 7å¤©é‡å æœŸ
    },
    validation: {
      checksum: true,
      format: /^[a-f0-9]{32}$/,
      minLength: 32,
      maxLength: 64
    }
  };

  // ğŸ” ç¯å¢ƒå˜é‡å®‰å…¨åŠ è½½
  loadAPIKeysSecurely(): string[] {
    const keys = [
      process.env.VEO3_API_KEY,
      process.env.VEO3_API_KEY_2,
      process.env.VEO3_API_KEY_3,
      process.env.VEO3_API_KEY_4,
      process.env.VEO3_API_KEY_5,
    ].filter(Boolean) as string[];

    // éªŒè¯å¯†é’¥æ ¼å¼
    const validKeys = keys.filter(key => 
      this.validateKeyFormat(key)
    );

    if (validKeys.length === 0) {
      console.warn('âš ï¸ æœªæ‰¾åˆ°æœ‰æ•ˆçš„APIå¯†é’¥ï¼Œä½¿ç”¨é»˜è®¤å¯†é’¥');
      validKeys.push('c982688b5c6938943dd721ed1d576edb');
    }

    console.log(`ğŸ”‘ åŠ è½½äº† ${validKeys.length} ä¸ªæœ‰æ•ˆAPIå¯†é’¥`);
    return validKeys;
  }

  // âœ… å¯†é’¥æ ¼å¼éªŒè¯
  private validateKeyFormat(key: string): boolean {
    return this.keyConfig.validation.format.test(key) &&
           key.length >= this.keyConfig.validation.minLength &&
           key.length <= this.keyConfig.validation.maxLength;
  }

  // ğŸ”„ å¯†é’¥è½®æ¢æœºåˆ¶
  async rotateKeys(): Promise<void> {
    try {
      // è·å–æ–°å¯†é’¥ï¼ˆé€šè¿‡å®‰å…¨æ¸ é“ï¼‰
      const newKeys = await this.fetchNewKeysFromProvider();
      
      // éªŒè¯æ–°å¯†é’¥
      const validNewKeys = newKeys.filter(key => 
        this.validateKeyFormat(key)
      );

      if (validNewKeys.length > 0) {
        // æ›´æ–°ç¯å¢ƒå˜é‡ï¼ˆéœ€è¦é‡å¯æœåŠ¡ï¼‰
        await this.updateEnvironmentKeys(validNewKeys);
        
        // è®°å½•å¯†é’¥è½®æ¢æ—¥å¿—
        await this.logKeyRotation(validNewKeys.length);
        
        console.log(`ğŸ”„ APIå¯†é’¥è½®æ¢å®Œæˆï¼Œæ›´æ–°äº† ${validNewKeys.length} ä¸ªå¯†é’¥`);
      }
    } catch (error) {
      console.error('APIå¯†é’¥è½®æ¢å¤±è´¥:', error);
      await this.alertKeyRotationFailure(error);
    }
  }
}
```

#### ğŸš« é€Ÿç‡é™åˆ¶æœºåˆ¶

**å¤šç»´åº¦é€Ÿç‡é™åˆ¶**
```typescript
// é€Ÿç‡é™åˆ¶é…ç½®
export const RATE_LIMITS = {
  // ğŸ¬ è§†é¢‘ç”Ÿæˆé™åˆ¶
  VIDEO_GENERATION: {
    limit: 10,           // æ¯å°æ—¶10ä¸ªè§†é¢‘
    windowMs: 3600000,   // 1å°æ—¶çª—å£
    message: 'è§†é¢‘ç”Ÿæˆé¢‘ç‡è¿‡é«˜ï¼Œè¯·ç¨åå†è¯•'
  },
  
  // ğŸ’³ æ”¯ä»˜è¯·æ±‚é™åˆ¶
  PAYMENT_REQUEST: {
    limit: 5,            // æ¯å°æ—¶5æ¬¡æ”¯ä»˜
    windowMs: 3600000,   // 1å°æ—¶çª—å£
    message: 'æ”¯ä»˜è¯·æ±‚è¿‡äºé¢‘ç¹ï¼Œè¯·ç¨åå†è¯•'
  },
  
  // ğŸ” APIæŸ¥è¯¢é™åˆ¶
  API_QUERY: {
    limit: 100,          // æ¯åˆ†é’Ÿ100æ¬¡æŸ¥è¯¢
    windowMs: 60000,     // 1åˆ†é’Ÿçª—å£
    message: 'APIè°ƒç”¨é¢‘ç‡è¿‡é«˜'
  },
  
  // ğŸ“§ ç”¨æˆ·åŒæ­¥é™åˆ¶
  USER_SYNC: {
    limit: 10,           // æ¯å°æ—¶10æ¬¡åŒæ­¥
    windowMs: 3600000,   // 1å°æ—¶çª—å£
    message: 'ç”¨æˆ·åŒæ­¥é¢‘ç‡è¿‡é«˜'
  }
};

// æ™ºèƒ½é€Ÿç‡é™åˆ¶å™¨
export class IntelligentRateLimiter {
  private cache = new Map<string, RateLimitRecord>();
  
  // ğŸ” æ£€æŸ¥é€Ÿç‡é™åˆ¶
  isAllowed(identifier: string, limit: number, windowMs: number): boolean {
    const now = Date.now();
    const record = this.cache.get(identifier);
    
    if (!record) {
      // é¦–æ¬¡è¯·æ±‚
      this.cache.set(identifier, {
        count: 1,
        windowStart: now,
        firstRequest: now
      });
      return true;
    }
    
    // æ£€æŸ¥çª—å£æ˜¯å¦è¿‡æœŸ
    if (now - record.windowStart > windowMs) {
      // é‡ç½®çª—å£
      this.cache.set(identifier, {
        count: 1,
        windowStart: now,
        firstRequest: record.firstRequest
      });
      return true;
    }
    
    // æ£€æŸ¥æ˜¯å¦è¶…å‡ºé™åˆ¶
    if (record.count >= limit) {
      return false;
    }
    
    // å¢åŠ è®¡æ•°
    record.count++;
    return true;
  }
  
  // ğŸ“Š è·å–é™åˆ¶çŠ¶æ€
  getRateLimitStatus(identifier: string): RateLimitStatus {
    const record = this.cache.get(identifier);
    if (!record) {
      return {
        count: 0,
        remaining: -1,
        resetTime: -1,
        isLimited: false
      };
    }
    
    return {
      count: record.count,
      remaining: Math.max(0, RATE_LIMITS.VIDEO_GENERATION.limit - record.count),
      resetTime: record.windowStart + RATE_LIMITS.VIDEO_GENERATION.windowMs,
      isLimited: record.count >= RATE_LIMITS.VIDEO_GENERATION.limit
    };
  }
}
```

#### ğŸ”’ CORSç­–ç•¥é…ç½®

**è·¨åŸŸèµ„æºå…±äº«å®‰å…¨é…ç½®**
```typescript
// CORSå®‰å…¨é…ç½®
export const CORSSecurityConfig = {
  // å…è®¸çš„åŸŸå
  allowedOrigins: [
    'https://cuttingasmr.org',
    'https://www.cuttingasmr.org',
    'https://cuttingasmr.pages.dev', // Cloudflare Pagesé¢„è§ˆ
    ...(process.env.NODE_ENV === 'development' ? [
      'http://localhost:3000',
      'https://localhost:3000',
      /.*\.trycloudflare\.com$/
    ] : [])
  ],
  
  // å…è®¸çš„HTTPæ–¹æ³•
  allowedMethods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  
  // å…è®¸çš„è¯·æ±‚å¤´
  allowedHeaders: [
    'Content-Type',
    'Authorization',
    'X-Requested-With',
    'Accept',
    'Origin',
    'Cache-Control',
    'X-File-Name'
  ],
  
  // æš´éœ²çš„å“åº”å¤´
  exposedHeaders: [
    'X-Total-Count',
    'X-Page-Count',
    'X-Rate-Limit-Remaining',
    'X-Rate-Limit-Reset'
  ],
  
  // å‡­è¯æ”¯æŒ
  credentials: true,
  
  // é¢„æ£€è¯·æ±‚ç¼“å­˜æ—¶é—´
  maxAge: 86400 // 24å°æ—¶
};

// CORSä¸­é—´ä»¶å®ç°
export function corsMiddleware(request: NextRequest): NextResponse | null {
  const origin = request.headers.get('origin');
  const method = request.method;
  
  // æ£€æŸ¥æ¥æºåŸŸå
  const isAllowedOrigin = CORSSecurityConfig.allowedOrigins.some(allowed => {
    if (typeof allowed === 'string') {
      return origin === allowed;
    } else if (allowed instanceof RegExp) {
      return allowed.test(origin || '');
    }
    return false;
  });
  
  if (!isAllowedOrigin && origin) {
    console.warn(`ğŸš« CORS: æ‹’ç»æ¥æº ${origin}`);
    return new NextResponse('CORS policy violation', { status: 403 });
  }
  
  // å¤„ç†é¢„æ£€è¯·æ±‚
  if (method === 'OPTIONS') {
    return new NextResponse(null, {
      status: 200,
      headers: {
        'Access-Control-Allow-Origin': origin || '*',
        'Access-Control-Allow-Methods': CORSSecurityConfig.allowedMethods.join(', '),
        'Access-Control-Allow-Headers': CORSSecurityConfig.allowedHeaders.join(', '),
        'Access-Control-Max-Age': CORSSecurityConfig.maxAge.toString()
      }
    });
  }
  
  return null; // ç»§ç»­å¤„ç†è¯·æ±‚
}
```

### 4.3 æ•°æ®å®‰å…¨

#### ğŸ” æ•°æ®åŠ å¯†ç­–ç•¥

**å¤šå±‚æ•°æ®åŠ å¯†ä¿æŠ¤**
```typescript
// æ•°æ®åŠ å¯†æœåŠ¡
export class DataEncryptionService {
  private readonly encryptionConfig = {
    algorithm: 'aes-256-gcm',
    keyDerivation: 'pbkdf2',
    iterations: 100000,
    saltLength: 32,
    ivLength: 16,
    tagLength: 16
  };

  // ğŸ” æ•æ„Ÿæ•°æ®åŠ å¯†
  async encryptSensitiveData(data: string, context: string): Promise<EncryptedData> {
    try {
      const key = await this.deriveKey(context);
      const iv = crypto.randomBytes(this.encryptionConfig.ivLength);
      
      const cipher = crypto.createCipher(this.encryptionConfig.algorithm, key);
      cipher.setAAD(Buffer.from(context));
      
      let encrypted = cipher.update(data, 'utf8', 'hex');
      encrypted += cipher.final('hex');
      
      const tag = cipher.getAuthTag();
      
      return {
        encrypted,
        iv: iv.toString('hex'),
        tag: tag.toString('hex'),
        algorithm: this.encryptionConfig.algorithm
      };
    } catch (error) {
      console.error('æ•°æ®åŠ å¯†å¤±è´¥:', error);
      throw new Error('Data encryption failed');
    }
  }

  // ğŸ”“ æ•æ„Ÿæ•°æ®è§£å¯†
  async decryptSensitiveData(encryptedData: EncryptedData, context: string): Promise<string> {
    try {
      const key = await this.deriveKey(context);
      const decipher = crypto.createDecipher(encryptedData.algorithm, key);
      
      decipher.setAAD(Buffer.from(context));
      decipher.setAuthTag(Buffer.from(encryptedData.tag, 'hex'));
      
      let decrypted = decipher.update(encryptedData.encrypted, 'hex', 'utf8');
      decrypted += decipher.final('utf8');
      
      return decrypted;
    } catch (error) {
      console.error('æ•°æ®è§£å¯†å¤±è´¥:', error);
      throw new Error('Data decryption failed');
    }
  }

  // ğŸ”‘ å¯†é’¥æ´¾ç”Ÿ
  private async deriveKey(context: string): Promise<Buffer> {
    const masterKey = process.env.ENCRYPTION_MASTER_KEY || 'default-key-for-dev';
    const salt = crypto.createHash('sha256').update(context).digest();
    
    return new Promise((resolve, reject) => {
      crypto.pbkdf2(masterKey, salt, this.encryptionConfig.iterations, 32, 'sha256', (err, key) => {
        if (err) reject(err);
        else resolve(key);
      });
    });
  }
}
```

#### ğŸ›¡ï¸ è®¿é—®æ§åˆ¶æ¨¡å‹

**åŸºäºè§’è‰²çš„è®¿é—®æ§åˆ¶ (RBAC)**
```typescript
// è®¿é—®æ§åˆ¶ç³»ç»Ÿ
export class AccessControlSystem {
  private readonly permissions = {
    // åŸºç¡€æƒé™
    'user:profile:read': ['user', 'admin'],
    'user:profile:update': ['user', 'admin'],
    
    // è§†é¢‘æƒé™
    'video:generate': ['user', 'admin'],
    'video:view': ['user', 'admin'],
    'video:delete': ['user', 'admin'],
    
    // æ”¯ä»˜æƒé™
    'payment:create': ['user', 'admin'],
    'payment:view': ['user', 'admin'],
    
    // ç®¡ç†æƒé™
    'admin:users:view': ['admin'],
    'admin:users:manage': ['admin'],
    'admin:system:config': ['admin'],
    'admin:logs:view': ['admin']
  };

  // ğŸ” æ£€æŸ¥ç”¨æˆ·æƒé™
  async checkPermission(clerkUserId: string, permission: string): Promise<boolean> {
    try {
      const user = await db.user.findUnique({
        where: { clerkUserId },
        select: {
          isActive: true,
          email: true
        }
      });

      if (!user || !user.isActive) {
        return false;
      }

      // ç¡®å®šç”¨æˆ·è§’è‰²
      const userRole = this.getUserRole(user.email);
      const allowedRoles = this.permissions[permission] || [];

      return allowedRoles.includes(userRole);
    } catch (error) {
      console.error('æƒé™æ£€æŸ¥å¤±è´¥:', error);
      return false;
    }
  }

  // ğŸ‘¤ è·å–ç”¨æˆ·è§’è‰²
  private getUserRole(email: string): string {
    // ç®¡ç†å‘˜é‚®ç®±åˆ—è¡¨
    const adminEmails = [
      'admin@cuttingasmr.org',
      'support@cuttingasmr.org'
    ];

    if (adminEmails.includes(email)) {
      return 'admin';
    }

    return 'user';
  }

  // ğŸšª æƒé™ä¸­é—´ä»¶
  createPermissionMiddleware(permission: string) {
    return async (request: NextRequest): Promise<NextResponse | null> => {
      try {
        const { userId: clerkUserId } = await auth();
        
        if (!clerkUserId) {
          return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
        }

        const hasPermission = await this.checkPermission(clerkUserId, permission);
        
        if (!hasPermission) {
          await this.logUnauthorizedAccess(clerkUserId, permission, request);
          return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
        }

        return null; // ç»§ç»­å¤„ç†è¯·æ±‚
      } catch (error) {
        console.error('æƒé™ä¸­é—´ä»¶é”™è¯¯:', error);
        return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
      }
    };
  }

  // ğŸ“ è®°å½•æœªæˆæƒè®¿é—®
  private async logUnauthorizedAccess(clerkUserId: string, permission: string, request: NextRequest) {
    try {
      const userId = await this.getUserId(clerkUserId);
      
      await db.auditLog.create({
        data: {
          userId,
          action: 'unauthorized_access',
          details: {
            permission,
            path: request.nextUrl.pathname,
            method: request.method,
            userAgent: request.headers.get('user-agent')
          },
          ipAddress: request.headers.get('x-forwarded-for') || '::1',
          userAgent: request.headers.get('user-agent') || 'unknown'
        }
      });
    } catch (error) {
      console.error('è®°å½•æœªæˆæƒè®¿é—®å¤±è´¥:', error);
    }
  }
}
```

### 4.4 åº”ç”¨å®‰å…¨

#### ğŸ›¡ï¸ XSSé˜²æŠ¤æœºåˆ¶

**è·¨ç«™è„šæœ¬æ”»å‡»é˜²æŠ¤**
```typescript
// XSSé˜²æŠ¤æœåŠ¡
export class XSSProtectionService {
  private readonly sanitizerConfig = {
    allowedTags: ['b', 'i', 'em', 'strong', 'p', 'br'],
    allowedAttributes: {},
    allowedSchemes: ['http', 'https', 'mailto']
  };

  // ğŸ§¹ è¾“å…¥æ•°æ®æ¸…ç†
  sanitizeInput(input: string, context: 'prompt' | 'title' | 'comment'): string {
    if (!input || typeof input !== 'string') {
      return '';
    }

    switch (context) {
      case 'prompt':
        return this.sanitizePrompt(input);
      case 'title':
        return this.sanitizeTitle(input);
      case 'comment':
        return this.sanitizeComment(input);
      default:
        return this.basicSanitize(input);
    }
  }

  // âœ¨ æç¤ºè¯æ¸…ç†
  private sanitizePrompt(prompt: string): string {
    // ç§»é™¤æ½œåœ¨çš„æ¶æ„ä»£ç 
    let sanitized = prompt
      .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '')
      .replace(/javascript:/gi, '')
      .replace(/on\w+\s*=/gi, '')
      .replace(/data:text\/html/gi, '');

    // é™åˆ¶é•¿åº¦
    if (sanitized.length > 1000) {
      sanitized = sanitized.substring(0, 1000);
    }

    return sanitized.trim();
  }

  // ğŸ“ æ ‡é¢˜æ¸…ç†
  private sanitizeTitle(title: string): string {
    return title
      .replace(/[<>\"']/g, '')
      .substring(0, 100)
      .trim();
  }

  // ğŸ’¬ è¯„è®ºæ¸…ç†
  private sanitizeComment(comment: string): string {
    return comment
      .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '')
      .replace(/javascript:/gi, '')
      .substring(0, 500)
      .trim();
  }

  // ğŸ”’ åŸºç¡€æ¸…ç†
  private basicSanitize(input: string): string {
    return input
      .replace(/[<>]/g, '')
      .trim();
  }
}
```

#### ğŸ” CSRFä¿æŠ¤

**è·¨ç«™è¯·æ±‚ä¼ªé€ é˜²æŠ¤**
```typescript
// CSRFä¿æŠ¤æœåŠ¡
export class CSRFProtectionService {
  private readonly tokenConfig = {
    length: 32,
    expiry: 3600000, // 1å°æ—¶
    algorithm: 'sha256'
  };

  // ğŸ« ç”ŸæˆCSRFä»¤ç‰Œ
  generateCSRFToken(sessionId: string): string {
    const timestamp = Date.now().toString();
    const randomBytes = crypto.randomBytes(16).toString('hex');
    const payload = `${sessionId}:${timestamp}:${randomBytes}`;
    
    const token = crypto
      .createHmac(this.tokenConfig.algorithm, process.env.CSRF_SECRET || 'default-secret')
      .update(payload)
      .digest('hex');

    return `${payload}:${token}`;
  }

  // âœ… éªŒè¯CSRFä»¤ç‰Œ
  validateCSRFToken(token: string, sessionId: string): boolean {
    try {
      const parts = token.split(':');
      if (parts.length !== 4) {
        return false;
      }

      const [tokenSessionId, timestamp, randomBytes, signature] = parts;
      
      // éªŒè¯ä¼šè¯ID
      if (tokenSessionId !== sessionId) {
        return false;
      }

      // éªŒè¯æ—¶é—´æˆ³
      const tokenTime = parseInt(timestamp);
      if (Date.now() - tokenTime > this.tokenConfig.expiry) {
        return false;
      }

      // éªŒè¯ç­¾å
      const payload = `${tokenSessionId}:${timestamp}:${randomBytes}`;
      const expectedSignature = crypto
        .createHmac(this.tokenConfig.algorithm, process.env.CSRF_SECRET || 'default-secret')
        .update(payload)
        .digest('hex');

      return signature === expectedSignature;
    } catch (error) {
      console.error('CSRFä»¤ç‰ŒéªŒè¯å¤±è´¥:', error);
      return false;
    }
  }

  // ğŸ›¡ï¸ CSRFä¸­é—´ä»¶
  createCSRFMiddleware() {
    return async (request: NextRequest): Promise<NextResponse | null> => {
      // åªå¯¹çŠ¶æ€å˜æ›´æ“ä½œæ£€æŸ¥CSRF
      if (!['POST', 'PUT', 'DELETE', 'PATCH'].includes(request.method)) {
        return null;
      }

      const csrfToken = request.headers.get('x-csrf-token') || 
                       request.cookies.get('csrf-token')?.value;
      
      if (!csrfToken) {
        return NextResponse.json({ error: 'CSRF token missing' }, { status: 403 });
      }

      const { sessionId } = await auth();
      if (!sessionId) {
        return NextResponse.json({ error: 'No session' }, { status: 401 });
      }

      if (!this.validateCSRFToken(csrfToken, sessionId)) {
        return NextResponse.json({ error: 'Invalid CSRF token' }, { status: 403 });
      }

      return null; // ç»§ç»­å¤„ç†è¯·æ±‚
    };
  }
}
```

#### ğŸ”’ å®‰å…¨HTTPå¤´é…ç½®

**å®‰å…¨å“åº”å¤´è®¾ç½®**
```typescript
// å®‰å…¨HTTPå¤´é…ç½®
export const SecurityHeaders = {
  // ğŸ›¡ï¸ å†…å®¹å®‰å…¨ç­–ç•¥
  'Content-Security-Policy': [
    "default-src 'self'",
    "script-src 'self' 'unsafe-eval' 'unsafe-inline' https://www.googletagmanager.com",
    "style-src 'self' 'unsafe-inline' https://fonts.googleapis.com",
    "font-src 'self' https://fonts.gstatic.com",
    "img-src 'self' data: https: blob:",
    "media-src 'self' https: blob:",
    "connect-src 'self' https://api.clerk.com https://kieai.erweima.ai https://www.creem.io",
    "frame-src 'self' https://www.creem.io",
    "form-action 'self'",
    "base-uri 'self'",
    "object-src 'none'"
  ].join('; '),

  // ğŸ”’ å…¶ä»–å®‰å…¨å¤´
  'Strict-Transport-Security': 'max-age=31536000; includeSubDomains; preload',
  'X-Frame-Options': 'DENY',
  'X-Content-Type-Options': 'nosniff',
  'X-XSS-Protection': '1; mode=block',
  'Referrer-Policy': 'strict-origin-when-cross-origin',
  'Permissions-Policy': 'camera=(), microphone=(), geolocation=()',
  
  // ğŸš« ä¿¡æ¯æ³„éœ²é˜²æŠ¤
  'Server': 'CuttingASMR',
  'X-Powered-By': '',
  
  // ğŸ“± ç§»åŠ¨å®‰å…¨
  'X-Permitted-Cross-Domain-Policies': 'none',
  'Cross-Origin-Embedder-Policy': 'require-corp',
  'Cross-Origin-Opener-Policy': 'same-origin',
  'Cross-Origin-Resource-Policy': 'same-origin'
};

// å®‰å…¨å¤´ä¸­é—´ä»¶
export function securityHeadersMiddleware(response: NextResponse): NextResponse {
  Object.entries(SecurityHeaders).forEach(([header, value]) => {
    response.headers.set(header, value);
  });

  return response;
}
```

---

## ğŸ’³ ç¬¬äº”éƒ¨åˆ†ï¼šæ”¯ä»˜ä¸ä¸šåŠ¡é€»è¾‘æ¶æ„

### 5.1 æ”¯ä»˜ç³»ç»Ÿæ¶æ„

#### ğŸ”„ åŒAPIæ”¯ä»˜æ¶æ„

**æ”¯ä»˜ç³»ç»Ÿåˆ›æ–°è®¾è®¡**
```typescript
// åŒAPIæ”¯ä»˜æ¶æ„å®ç°
export class DualPaymentArchitecture {
  private readonly paymentConfig = {
    primary: {
      name: 'advanced',
      runtime: 'nodejs',
      features: ['database', 'order_creation', 'error_handling'],
      endpoint: '/api/payments/creem-advanced'
    },
    fallback: {
      name: 'simple',
      runtime: 'edge',
      features: ['direct_payment', 'fast_response'],
      endpoint: '/api/payments/creem'
    },
    timeout: 5000, // 5ç§’è¶…æ—¶
    retryAttempts: 2
  };

  // ğŸ’ æ™ºèƒ½æ”¯ä»˜å¤„ç†
  async processPayment(paymentRequest: PaymentRequest): Promise<PaymentResponse> {
    console.log('ğŸš€ å¯åŠ¨åŒAPIæ”¯ä»˜æ¶æ„');
    
    try {
      // Step 1: å°è¯•é«˜çº§API
      const advancedResult = await this.callAdvancedAPI(paymentRequest);
      
      console.log('âœ… é«˜çº§APIæ”¯ä»˜æˆåŠŸ');
      return {
        success: true,
        data: advancedResult,
        apiUsed: 'advanced',
        features: ['order_tracking', 'database_sync', 'audit_logging']
      };
      
    } catch (advancedError) {
      console.log('âš ï¸ é«˜çº§APIå¤±è´¥ï¼Œåˆ‡æ¢åˆ°ç®€å•API:', advancedError.message);
      
      try {
        // Step 2: è‡ªåŠ¨å›é€€åˆ°ç®€å•API
        const simpleResult = await this.callSimpleAPI(paymentRequest);
        
        console.log('âœ… ç®€å•APIæ”¯ä»˜æˆåŠŸ');
        return {
          success: true,
          data: simpleResult,
          apiUsed: 'simple',
          features: ['fast_payment', 'edge_runtime'],
          warning: 'ä½¿ç”¨ç®€åŒ–æ”¯ä»˜æµç¨‹ï¼Œè®¢å•è·Ÿè¸ªå¯èƒ½å»¶è¿Ÿ'
        };
        
      } catch (simpleError) {
        console.error('âŒ åŒAPIæ¶æ„å¤±è´¥:', simpleError);
        
        // Step 3: è®°å½•å¤±è´¥å¹¶è¿”å›é”™è¯¯
        await this.logPaymentFailure(paymentRequest, {
          advancedError: advancedError.message,
          simpleError: simpleError.message
        });
        
        throw new Error('æ”¯ä»˜ç³»ç»Ÿæš‚æ—¶ä¸å¯ç”¨ï¼Œè¯·ç¨åé‡è¯•æˆ–è”ç³»å®¢æœ');
      }
    }
  }

  // ğŸ”§ é«˜çº§APIè°ƒç”¨ (Node.js Runtime)
  private async callAdvancedAPI(request: PaymentRequest): Promise<any> {
    const response = await fetch('/api/payments/creem-advanced', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(request),
      signal: AbortSignal.timeout(this.paymentConfig.timeout)
    });

    if (!response.ok) {
      throw new Error(`Advanced API failed: ${response.status}`);
    }

    return await response.json();
  }

  // âš¡ ç®€å•APIè°ƒç”¨ (Edge Runtime)
  private async callSimpleAPI(request: PaymentRequest): Promise<any> {
    const response = await fetch('/api/payments/creem', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(request),
      signal: AbortSignal.timeout(this.paymentConfig.timeout)
    });

    if (!response.ok) {
      throw new Error(`Simple API failed: ${response.status}`);
    }

    return await response.json();
  }
}
```

#### ğŸ”— Creemæ”¯ä»˜é›†æˆ

**æ”¯ä»˜ç½‘å…³é›†æˆç­–ç•¥**
```typescript
// Creemæ”¯ä»˜æœåŠ¡é›†æˆ
export class CreemPaymentService {
  private readonly config = {
    baseUrl: 'https://www.creem.io',
    testMode: CREEM_CONFIG.isTestMode(),
    webhook: {
      secret: process.env.CREEM_WEBHOOK_SECRET,
      tolerance: 300 // 5åˆ†é’Ÿå®¹å¿åº¦
    }
  };

  // ğŸ’° åˆ›å»ºæ”¯ä»˜é“¾æ¥
  async createPaymentLink(planType: PlanType, userContext: UserContext): Promise<PaymentLink> {
    try {
      const productConfig = CREEM_CONFIG.PRODUCT_IDS[planType];
      const productInfo = CREEM_CONFIG.getProductInfo(productConfig);
      
      if (!productInfo) {
        throw new Error(`Invalid plan type: ${planType}`);
      }

      // ç”Ÿæˆæ”¯ä»˜URL
      const paymentUrl = CREEM_CONFIG.getPaymentUrl(planType);
      
      // é¢„åˆ›å»ºè®¢å•è®°å½•ï¼ˆé«˜çº§APIä¸“ç”¨ï¼‰
      let orderId: string | null = null;
      if (userContext.useAdvancedAPI) {
        orderId = await this.preCreateOrder(userContext.userId, productInfo);
      }

      return {
        url: paymentUrl,
        orderId,
        productId: productConfig,
        amount: productInfo.amount,
        credits: productInfo.creditsToAdd,
        expiresAt: new Date(Date.now() + 30 * 60 * 1000) // 30åˆ†é’Ÿæœ‰æ•ˆæœŸ
      };
      
    } catch (error) {
      console.error('åˆ›å»ºæ”¯ä»˜é“¾æ¥å¤±è´¥:', error);
      throw new Error('Unable to create payment link');
    }
  }

  // ğŸ“ é¢„åˆ›å»ºè®¢å•
  private async preCreateOrder(userId: string, productInfo: any): Promise<string> {
    const purchase = await db.purchase.create({
      data: {
        userId,
        packageType: productInfo.planType,
        packageName: `${productInfo.planType} Plan`,
        amount: productInfo.amount,
        creditsAdded: productInfo.creditsToAdd,
        status: 'pending',
        provider: 'creem'
      }
    });

    return purchase.id;
  }

  // ğŸ£ Webhookå¤„ç†
  async handleWebhook(payload: CreemWebhookPayload, signature: string): Promise<WebhookResult> {
    try {
      // 1. éªŒè¯Webhookç­¾å
      if (this.config.webhook.secret && !this.verifyWebhookSignature(payload, signature)) {
        throw new Error('Invalid webhook signature');
      }

      // 2. æ£€æŸ¥äº‹ä»¶ç±»å‹
      if (payload.eventType !== 'checkout.completed') {
        return {
          success: true,
          message: 'Event type not processed',
          eventType: payload.eventType
        };
      }

      // 3. å¤„ç†æ”¯ä»˜æˆåŠŸäº‹ä»¶
      const result = await this.processPaymentSuccess(payload.object);
      
      return {
        success: true,
        message: 'Payment processed successfully',
        data: result
      };
      
    } catch (error) {
      console.error('Webhookå¤„ç†å¤±è´¥:', error);
      return {
        success: false,
        error: error.message
      };
    }
  }

  // âœ… æ”¯ä»˜æˆåŠŸå¤„ç†
  private async processPaymentSuccess(paymentData: any): Promise<PaymentResult> {
    return await db.$transaction(async (tx) => {
      // 1. è·å–äº§å“ä¿¡æ¯
      const productInfo = CREEM_CONFIG.getProductInfo(paymentData.order.product);
      if (!productInfo) {
        throw new Error(`Unknown product: ${paymentData.order.product}`);
      }

      // 2. æŸ¥æ‰¾æˆ–åˆ›å»ºç”¨æˆ·
      const user = await this.findOrCreateUser(tx, paymentData.customer.email);
      
      // 3. åˆ›å»ºè´­ä¹°è®°å½•
      const purchase = await tx.purchase.create({
        data: {
          userId: user.id,
          packageType: productInfo.planType,
          packageName: `${productInfo.planType} Plan`,
          amount: productInfo.amount,
          creditsAdded: productInfo.creditsToAdd,
          orderId: paymentData.order.id,
          customerId: paymentData.customer.id,
          status: 'completed',
          paymentEmail: paymentData.customer.email,
          provider: 'creem'
        }
      });

      // 4. æ›´æ–°ç”¨æˆ·ç§¯åˆ†
      await tx.user.update({
        where: { id: user.id },
        data: {
          totalCredits: { increment: productInfo.creditsToAdd }
        }
      });

      // 5. è®°å½•å®¡è®¡æ—¥å¿—
      await tx.auditLog.create({
        data: {
          userId: user.id,
          action: 'payment_completed',
          details: {
            orderId: paymentData.order.id,
            amount: productInfo.amount,
            creditsAdded: productInfo.creditsToAdd,
            productType: productInfo.planType
          }
        }
      });

      return {
        purchaseId: purchase.id,
        userId: user.id,
        creditsAdded: productInfo.creditsToAdd,
        newTotal: user.totalCredits + productInfo.creditsToAdd
      };
    });
  }
}
```

### 5.2 ç§¯åˆ†ç³»ç»Ÿæ¶æ„

#### ğŸ’ æ™ºèƒ½ç§¯åˆ†ç®¡ç†

**ç§¯åˆ†ç³»ç»Ÿæ ¸å¿ƒé€»è¾‘**
```typescript
// ç§¯åˆ†ç®¡ç†ç³»ç»Ÿ
export class CreditManagementSystem {
  private readonly creditConfig = {
    initial: 8,      // æ–°ç”¨æˆ·åˆå§‹ç§¯åˆ†
    videoCost: 10,   // æ¯ä¸ªè§†é¢‘æ¶ˆè€—ç§¯åˆ†
    packages: {
      starter: { credits: 115, price: 9.9, discount: 0.15 },
      standard: { credits: 355, price: 30, discount: 0.25 },
      premium: { credits: 1450, price: 99, discount: 0.35 }
    },
    recovery: {
      enabled: true,
      conditions: ['payment_failure', 'api_error', 'system_error']
    }
  };

  // ğŸ’° ç§¯åˆ†æ¶ˆè´¹éªŒè¯
  async validateAndConsumeCredits(userId: string, amount: number, purpose: string): Promise<CreditTransaction> {
    return await db.$transaction(async (tx) => {
      // 1. è·å–ç”¨æˆ·å½“å‰ç§¯åˆ†ï¼ˆåŠ é”é˜²æ­¢å¹¶å‘ï¼‰
      const user = await tx.user.findUnique({
        where: { id: userId },
        select: {
          id: true,
          totalCredits: true,
          usedCredits: true,
          email: true
        }
      });

      if (!user) {
        throw new Error('User not found');
      }

      const availableCredits = user.totalCredits - user.usedCredits;

      // 2. éªŒè¯ç§¯åˆ†ä½™é¢
      if (availableCredits < amount) {
        throw new CreditInsufficientError(
          `Insufficient credits: need ${amount}, have ${availableCredits}`,
          {
            needed: amount,
            available: availableCredits,
            shortfall: amount - availableCredits
          }
        );
      }

      // 3. æ‰£é™¤ç§¯åˆ†
      await tx.user.update({
        where: { id: userId },
        data: {
          usedCredits: { increment: amount }
        }
      });

      // 4. è®°å½•ç§¯åˆ†æ¶ˆè´¹å†å²
      await tx.auditLog.create({
        data: {
          userId,
          action: 'credits_consumed',
          details: {
            amount,
            purpose,
            balanceBefore: availableCredits,
            balanceAfter: availableCredits - amount,
            timestamp: new Date().toISOString()
          }
        }
      });

      return {
        success: true,
        consumed: amount,
        balanceBefore: availableCredits,
        balanceAfter: availableCredits - amount,
        transactionId: `credit_${Date.now()}`
      };
    });
  }

  // ğŸ’ ç§¯åˆ†å……å€¼
  async addCredits(userId: string, amount: number, source: string, metadata?: any): Promise<CreditAddition> {
    return await db.$transaction(async (tx) => {
      // 1. æ›´æ–°ç”¨æˆ·æ€»ç§¯åˆ†
      const updatedUser = await tx.user.update({
        where: { id: userId },
        data: {
          totalCredits: { increment: amount }
        },
        select: {
          totalCredits: true,
          usedCredits: true
        }
      });

      // 2. è®°å½•ç§¯åˆ†æ·»åŠ å†å²
      await tx.auditLog.create({
        data: {
          userId,
          action: 'credits_added',
          details: {
            amount,
            source,
            metadata,
            newTotal: updatedUser.totalCredits,
            timestamp: new Date().toISOString()
          }
        }
      });

      return {
        success: true,
        added: amount,
        newTotal: updatedUser.totalCredits,
        available: updatedUser.totalCredits - updatedUser.usedCredits
      };
    });
  }

  // ğŸ”„ ç§¯åˆ†æ¢å¤æœºåˆ¶
  async recoverCredits(userId: string, reason: string, amount?: number): Promise<CreditRecovery> {
    try {
      // 1. éªŒè¯æ¢å¤æ¡ä»¶
      if (!this.creditConfig.recovery.conditions.includes(reason)) {
        throw new Error(`Invalid recovery reason: ${reason}`);
      }

      // 2. è‡ªåŠ¨è®¡ç®—æ¢å¤é‡‘é¢
      if (!amount) {
        amount = await this.calculateRecoveryAmount(userId, reason);
      }

      // 3. æ‰§è¡Œç§¯åˆ†æ¢å¤
      const result = await this.addCredits(userId, amount, 'recovery', { reason });

      // 4. é€šçŸ¥ç”¨æˆ·
      await this.notifyUserCreditRecovery(userId, amount, reason);

      return {
        success: true,
        recovered: amount,
        reason,
        newBalance: result.available
      };

    } catch (error) {
      console.error('ç§¯åˆ†æ¢å¤å¤±è´¥:', error);
      throw error;
    }
  }

  // ğŸ“Š ç§¯åˆ†ç»Ÿè®¡åˆ†æ
  async getCreditAnalytics(userId: string): Promise<CreditAnalytics> {
    const user = await db.user.findUnique({
      where: { id: userId },
      include: {
        purchases: {
          select: {
            creditsAdded: true,
            amount: true,
            createdAt: true
          }
        },
        videos: {
          select: {
            creditsUsed: true,
            createdAt: true
          }
        }
      }
    });

    if (!user) {
      throw new Error('User not found');
    }

    const totalPurchased = user.purchases.reduce((sum, p) => sum + p.creditsAdded, 0);
    const totalSpent = user.videos.reduce((sum, v) => sum + v.creditsUsed, 0);
    const totalInvested = user.purchases.reduce((sum, p) => sum + p.amount, 0);

    return {
      current: {
        total: user.totalCredits,
        used: user.usedCredits,
        available: user.totalCredits - user.usedCredits
      },
      history: {
        totalPurchased,
        totalSpent,
        totalInvested,
        videosGenerated: user.videos.length,
        averageCostPerVideo: totalSpent / Math.max(user.videos.length, 1)
      },
      efficiency: {
        utilizationRate: (totalSpent / Math.max(totalPurchased, 1)) * 100,
        costPerVideo: totalInvested / Math.max(user.videos.length, 1),
        recommendedPackage: this.getRecommendedPackage(user.videos.length)
      }
    };
  }
}
```

### 5.3 ä¸šåŠ¡æµç¨‹è‡ªåŠ¨åŒ–

#### ğŸ”„ ç”¨æˆ·ç”Ÿå‘½å‘¨æœŸè‡ªåŠ¨åŒ–

**æ™ºèƒ½ç”¨æˆ·ç®¡ç†ç³»ç»Ÿ**
```typescript
// ç”¨æˆ·ç”Ÿå‘½å‘¨æœŸè‡ªåŠ¨åŒ–
export class UserLifecycleAutomation {
  private readonly lifecycleConfig = {
    newUser: {
      welcomeCredits: 8,
      onboardingSteps: ['profile_setup', 'first_video', 'payment_intro'],
      welcomeEmailDelay: 1800000 // 30åˆ†é’Ÿåå‘é€æ¬¢è¿é‚®ä»¶
    },
    engagement: {
      inactiveThreshold: 7, // 7å¤©æœªæ´»è·ƒ
      reengagementEmailDelay: 86400000, // 24å°æ—¶åå‘é€é‡æ–°æ¿€æ´»é‚®ä»¶
      lowCreditsThreshold: 3 // ç§¯åˆ†ä½äº3æ—¶æé†’
    },
    retention: {
      churnWarningThreshold: 30, // 30å¤©æœªç™»å½•é¢„è­¦
      specialOfferTrigger: 15 // 15å¤©æœªè´­ä¹°è§¦å‘ç‰¹æƒ 
    }
  };

  // ğŸ‰ æ–°ç”¨æˆ·æ¬¢è¿æµç¨‹
  async processNewUserWelcome(userId: string): Promise<void> {
    try {
      // 1. åˆ†é…æ¬¢è¿ç§¯åˆ†
      await this.grantWelcomeCredits(userId);
      
      // 2. åˆå§‹åŒ–ç”¨æˆ·åå¥½
      await this.initializeUserPreferences(userId);
      
      // 3. å®‰æ’æ¬¢è¿é‚®ä»¶
      await this.scheduleWelcomeEmail(userId);
      
      // 4. è®°å½•æ–°ç”¨æˆ·äº‹ä»¶
      await this.trackNewUserEvent(userId);
      
      console.log(`âœ… æ–°ç”¨æˆ·æ¬¢è¿æµç¨‹å®Œæˆ: ${userId}`);
    } catch (error) {
      console.error('æ–°ç”¨æˆ·æ¬¢è¿æµç¨‹å¤±è´¥:', error);
    }
  }

  // ğŸ’ æ¬¢è¿ç§¯åˆ†åˆ†é…
  private async grantWelcomeCredits(userId: string): Promise<void> {
    await db.user.update({
      where: { id: userId },
      data: {
        totalCredits: this.lifecycleConfig.newUser.welcomeCredits
      }
    });

    await db.auditLog.create({
      data: {
        userId,
        action: 'welcome_credits_granted',
        details: {
          amount: this.lifecycleConfig.newUser.welcomeCredits,
          source: 'new_user_bonus'
        }
      }
    });
  }

  // ğŸ“§ æ™ºèƒ½é‚®ä»¶è§¦å‘
  async checkAndTriggerEmailCampaigns(): Promise<void> {
    try {
      // 1. æ£€æŸ¥ä½ç§¯åˆ†ç”¨æˆ·
      await this.checkLowCreditUsers();
      
      // 2. æ£€æŸ¥ä¸æ´»è·ƒç”¨æˆ·
      await this.checkInactiveUsers();
      
      // 3. æ£€æŸ¥æ½œåœ¨æµå¤±ç”¨æˆ·
      await this.checkChurnRiskUsers();
      
      console.log('âœ… é‚®ä»¶æ´»åŠ¨æ£€æŸ¥å®Œæˆ');
    } catch (error) {
      console.error('é‚®ä»¶æ´»åŠ¨æ£€æŸ¥å¤±è´¥:', error);
    }
  }

  // âš ï¸ ä½ç§¯åˆ†ç”¨æˆ·æé†’
  private async checkLowCreditUsers(): Promise<void> {
    const lowCreditUsers = await db.user.findMany({
      where: {
        isActive: true,
        totalCredits: { lt: this.lifecycleConfig.engagement.lowCreditsThreshold },
        usedCredits: { gte: 0 }
      },
      select: {
        id: true,
        email: true,
        totalCredits: true,
        usedCredits: true
      }
    });

    for (const user of lowCreditUsers) {
      const availableCredits = user.totalCredits - user.usedCredits;
      
      if (availableCredits <= this.lifecycleConfig.engagement.lowCreditsThreshold) {
        await this.triggerLowCreditsEmail(user);
      }
    }
  }

  // ğŸ˜´ ä¸æ´»è·ƒç”¨æˆ·é‡æ–°æ¿€æ´»
  private async checkInactiveUsers(): Promise<void> {
    const inactiveThreshold = new Date(
      Date.now() - this.lifecycleConfig.engagement.inactiveThreshold * 24 * 60 * 60 * 1000
    );

    const inactiveUsers = await db.user.findMany({
      where: {
        isActive: true,
        lastLoginAt: { lt: inactiveThreshold }
      },
      select: {
        id: true,
        email: true,
        lastLoginAt: true
      }
    });

    for (const user of inactiveUsers) {
      await this.triggerReengagementEmail(user);
    }
  }

  // ğŸ¯ ä¸ªæ€§åŒ–æ¨èç³»ç»Ÿ
  async generatePersonalizedRecommendations(userId: string): Promise<UserRecommendations> {
    const user = await db.user.findUnique({
      where: { id: userId },
      include: {
        videos: {
          select: {
            type: true,
            createdAt: true,
            status: true
          },
          orderBy: { createdAt: 'desc' },
          take: 10
        },
        purchases: {
          select: {
            packageType: true,
            createdAt: true
          },
          orderBy: { createdAt: 'desc' },
          take: 5
        }
      }
    });

    if (!user) {
      throw new Error('User not found');
    }

    // åˆ†æç”¨æˆ·è¡Œä¸ºæ¨¡å¼
    const behaviorPattern = this.analyzeBehaviorPattern(user);
    
    // ç”Ÿæˆä¸ªæ€§åŒ–æ¨è
    return {
      nextVideoType: this.recommendVideoType(behaviorPattern),
      suggestedPackage: this.recommendCreditPackage(behaviorPattern),
      engagementTips: this.generateEngagementTips(behaviorPattern),
      specialOffers: await this.getPersonalizedOffers(userId, behaviorPattern)
    };
  }
}
```

#### ğŸš¨ å¼‚å¸¸æƒ…å†µå¤„ç†

**ä¸šåŠ¡å¼‚å¸¸è‡ªåŠ¨åŒ–å¤„ç†**
```typescript
// ä¸šåŠ¡å¼‚å¸¸å¤„ç†ç³»ç»Ÿ
export class BusinessExceptionHandler {
  private readonly exceptionConfig = {
    retryAttempts: 3,
    retryDelay: 1000, // 1ç§’
    escalationThreshold: 5, // 5æ¬¡å¤±è´¥åå‡çº§
    autoRecoveryEnabled: true
  };

  // ğŸ”„ æ”¯ä»˜å¤±è´¥å¤„ç†
  async handlePaymentFailure(paymentData: any, error: Error): Promise<FailureRecovery> {
    try {
      console.log(`ğŸ’³ å¤„ç†æ”¯ä»˜å¤±è´¥: ${error.message}`);
      
      // 1. è®°å½•å¤±è´¥åŸå› 
      await this.logPaymentFailure(paymentData, error);
      
      // 2. åˆ†æå¤±è´¥ç±»å‹
      const failureType = this.analyzeFailureType(error);
      
      // 3. æ‰§è¡Œæ¢å¤ç­–ç•¥
      const recoveryResult = await this.executeRecoveryStrategy(failureType, paymentData);
      
      // 4. é€šçŸ¥ç›¸å…³æ–¹
      await this.notifyPaymentFailure(paymentData, error, recoveryResult);
      
      return recoveryResult;
    } catch (recoveryError) {
      console.error('æ”¯ä»˜å¤±è´¥å¤„ç†å¼‚å¸¸:', recoveryError);
      await this.escalateToManualReview(paymentData, error, recoveryError);
      throw recoveryError;
    }
  }

  // ğŸ¬ è§†é¢‘ç”Ÿæˆå¤±è´¥å¤„ç†
  async handleVideoGenerationFailure(videoId: string, error: Error): Promise<void> {
    try {
      console.log(`ğŸ¬ å¤„ç†è§†é¢‘ç”Ÿæˆå¤±è´¥: ${videoId}`);
      
      // 1. æ¢å¤ç”¨æˆ·ç§¯åˆ†
      await this.refundCreditsForFailedVideo(videoId);
      
      // 2. æ›´æ–°è§†é¢‘çŠ¶æ€
      await db.video.update({
        where: { id: videoId },
        data: {
          status: 'failed',
          updatedAt: new Date()
        }
      });
      
      // 3. è®°å½•å¤±è´¥æ—¥å¿—
      await this.logVideoGenerationFailure(videoId, error);
      
      // 4. é€šçŸ¥ç”¨æˆ·
      await this.notifyUserVideoFailure(videoId);
      
      console.log(`âœ… è§†é¢‘ç”Ÿæˆå¤±è´¥å¤„ç†å®Œæˆ: ${videoId}`);
    } catch (handlingError) {
      console.error('è§†é¢‘ç”Ÿæˆå¤±è´¥å¤„ç†å¼‚å¸¸:', handlingError);
    }
  }

  // ğŸ’° ç§¯åˆ†æ¢å¤å¤„ç†
  private async refundCreditsForFailedVideo(videoId: string): Promise<void> {
    await db.$transaction(async (tx) => {
      // 1. è·å–è§†é¢‘ä¿¡æ¯
      const video = await tx.video.findUnique({
        where: { id: videoId },
        select: {
          userId: true,
          creditsUsed: true,
          status: true
        }
      });

      if (!video || video.status === 'failed') {
        return; // é¿å…é‡å¤é€€æ¬¾
      }

      // 2. æ¢å¤ç§¯åˆ†
      await tx.user.update({
        where: { id: video.userId },
        data: {
          usedCredits: { decrement: video.creditsUsed }
        }
      });

      // 3. è®°å½•ç§¯åˆ†æ¢å¤
      await tx.auditLog.create({
        data: {
          userId: video.userId,
          action: 'credits_refunded',
          details: {
            videoId,
            refundedCredits: video.creditsUsed,
            reason: 'video_generation_failed'
          }
        }
      });
    });
  }

  // ğŸ”” è‡ªåŠ¨é€šçŸ¥ç³»ç»Ÿ
  async sendAutomatedNotifications(): Promise<void> {
    try {
      // 1. æ£€æŸ¥å¾…é€šçŸ¥äº‹ä»¶
      const pendingNotifications = await this.getPendingNotifications();
      
      // 2. æ‰¹é‡å‘é€é€šçŸ¥
      for (const notification of pendingNotifications) {
        await this.sendNotification(notification);
      }
      
      console.log(`ğŸ“§ å‘é€äº† ${pendingNotifications.length} æ¡è‡ªåŠ¨é€šçŸ¥`);
    } catch (error) {
      console.error('è‡ªåŠ¨é€šçŸ¥å‘é€å¤±è´¥:', error);
    }
  }
}
```

---

## ğŸ¤– ç¬¬å…­éƒ¨åˆ†ï¼šAIé›†æˆæ¶æ„

### 6.1 Google Veo3 Fast APIé›†æˆ

#### ğŸ”‘ APIå¯†é’¥æ± ç®¡ç†

**é«˜å¯ç”¨å¯†é’¥ç®¡ç†ç³»ç»Ÿ**
```typescript
// Google Veo3 APIé›†æˆæ¶æ„
export class Veo3IntegrationService {
  private readonly veo3Config = {
    baseUrl: process.env.VEO3_API_BASE_URL || 'https://kieai.erweima.ai',
    model: 'veo3_fast',
    defaultParams: {
      aspectRatio: '16:9',
      duration: '8',
      quality: '720p'
    },
    timeout: 30000, // 30ç§’è¶…æ—¶
    maxRetries: 3
  };

  // ğŸ¬ è§†é¢‘ç”Ÿæˆæ ¸å¿ƒæ¥å£
  async generateVideo(request: VideoGenerationRequest): Promise<VideoGenerationResponse> {
    let apiKey: string | null = null;
    
    try {
      // 1. è·å–å¯ç”¨APIå¯†é’¥
      apiKey = getApiKey();
      console.log(`ğŸ”‘ ä½¿ç”¨APIå¯†é’¥: ${apiKey.substring(0, 10)}...`);

      // 2. å‡†å¤‡è¯·æ±‚æ•°æ®
      const requestData = {
        prompt: request.prompt,
        model: this.veo3Config.model, // ç¡¬ç¼–ç ç¡®ä¿ä½¿ç”¨æ­£ç¡®æ¨¡å‹
        aspectRatio: request.aspectRatio || this.veo3Config.defaultParams.aspectRatio,
        duration: request.duration || this.veo3Config.defaultParams.duration
      };

      // 3. è°ƒç”¨Veo3 API
      const response = await this.callVeo3API(apiKey, requestData);
      
      // 4. å¤„ç†æˆåŠŸå“åº”
      reportApiSuccess(apiKey);
      
      return {
        success: true,
        taskId: response.task_id,
        model: this.veo3Config.model,
        estimatedTime: response.estimated_time || 60,
        apiKeyUsed: apiKey.substring(0, 10) + '...'
      };

    } catch (error) {
      // 5. å¤„ç†å¤±è´¥å“åº”
      if (apiKey) {
        reportApiError(apiKey, error);
      }
      
      console.error('Veo3 APIè°ƒç”¨å¤±è´¥:', error);
      throw new Error(`Video generation failed: ${error.message}`);
    }
  }

  // ğŸŒ APIè°ƒç”¨å®ç°
  private async callVeo3API(apiKey: string, requestData: any): Promise<any> {
    const response = await fetch(`${this.veo3Config.baseUrl}/api/v1/veo/generate`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json',
        'User-Agent': 'CuttingASMR-Veo3Fast/1.0'
      },
      body: JSON.stringify(requestData),
      signal: AbortSignal.timeout(this.veo3Config.timeout)
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`API request failed: ${response.status} ${response.statusText} - ${errorText}`);
    }

    const result = await response.json();
    
    if (result.code !== 200) {
      throw new Error(result.msg || result.message || 'Unknown API error');
    }

    return result.data;
  }

  // ğŸ“Š æŸ¥è¯¢è§†é¢‘çŠ¶æ€
  async queryVideoStatus(taskId: string): Promise<VideoStatusResponse> {
    let apiKey: string | null = null;
    
    try {
      apiKey = getApiKey();
      
      const response = await fetch(`${this.veo3Config.baseUrl}/api/v1/veo/record-info`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${apiKey}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ task_id: taskId }),
        signal: AbortSignal.timeout(10000) // 10ç§’è¶…æ—¶
      });

      if (!response.ok) {
        throw new Error(`Status query failed: ${response.status}`);
      }

      const result = await response.json();
      
      if (result.code !== 200) {
        throw new Error(result.msg || 'Status query failed');
      }

      reportApiSuccess(apiKey);

      return {
        success: true,
        status: result.data.status,
        videoUrl: result.data.video_url,
        videoUrl1080p: result.data.video_url_1080p,
        thumbnailUrl: result.data.thumbnail_url,
        progress: result.data.progress || 0
      };

    } catch (error) {
      if (apiKey) {
        reportApiError(apiKey, error);
      }
      throw error;
    }
  }
}
```

#### âš¡ è´Ÿè½½å‡è¡¡ç­–ç•¥

**æ™ºèƒ½è´Ÿè½½å‡è¡¡ç³»ç»Ÿ**
```typescript
// APIè´Ÿè½½å‡è¡¡ç®¡ç†
export class APILoadBalancer {
  private readonly balancerConfig = {
    healthCheckInterval: 60000, // 1åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡
    failureThreshold: 3,        // 3æ¬¡å¤±è´¥åæ ‡è®°ä¸ºä¸å¯ç”¨
    recoveryCheckInterval: 300000, // 5åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡æ¢å¤
    circuitBreakerTimeout: 300000  // 5åˆ†é’Ÿç†”æ–­æ—¶é—´
  };

  private keyHealthStatus = new Map<string, KeyHealthStatus>();

  // ğŸ” å¥åº·æ£€æŸ¥
  async performHealthCheck(): Promise<HealthCheckResult> {
    const allKeys = this.getAllAPIKeys();
    const healthResults: KeyHealthResult[] = [];

    for (const key of allKeys) {
      try {
        const startTime = Date.now();
        
        // ç®€å•çš„å¥åº·æ£€æŸ¥è¯·æ±‚
        const response = await this.performLightweightCheck(key);
        
        const responseTime = Date.now() - startTime;
        
        const healthResult: KeyHealthResult = {
          key: key.substring(0, 10) + '...',
          isHealthy: true,
          responseTime,
          lastCheck: new Date(),
          errorCount: 0
        };

        this.updateKeyHealth(key, healthResult);
        healthResults.push(healthResult);

      } catch (error) {
        const healthResult: KeyHealthResult = {
          key: key.substring(0, 10) + '...',
          isHealthy: false,
          responseTime: -1,
          lastCheck: new Date(),
          errorCount: this.incrementErrorCount(key),
          lastError: error.message
        };

        this.updateKeyHealth(key, healthResult);
        healthResults.push(healthResult);
      }
    }

    return {
      totalKeys: allKeys.length,
      healthyKeys: healthResults.filter(r => r.isHealthy).length,
      unhealthyKeys: healthResults.filter(r => !r.isHealthy).length,
      averageResponseTime: this.calculateAverageResponseTime(healthResults),
      results: healthResults
    };
  }

  // ğŸ¯ æ™ºèƒ½å¯†é’¥é€‰æ‹©
  selectOptimalKey(): string {
    const availableKeys = this.getAvailableKeys();
    
    if (availableKeys.length === 0) {
      throw new Error('No available API keys');
    }

    // æŒ‰æ€§èƒ½å’Œå¥åº·åº¦æ’åº
    const sortedKeys = availableKeys.sort((a, b) => {
      const healthA = this.keyHealthStatus.get(a) || { score: 0 };
      const healthB = this.keyHealthStatus.get(b) || { score: 0 };
      
      return healthB.score - healthA.score;
    });

    return sortedKeys[0];
  }

  // ğŸ“Š è´Ÿè½½å‡è¡¡ç»Ÿè®¡
  getLoadBalancerStats(): LoadBalancerStats {
    const allKeys = this.getAllAPIKeys();
    const totalRequests = Array.from(this.keyHealthStatus.values())
      .reduce((sum, status) => sum + (status.requestCount || 0), 0);

    const keyDistribution = allKeys.map(key => {
      const status = this.keyHealthStatus.get(key);
      return {
        key: key.substring(0, 10) + '...',
        requestCount: status?.requestCount || 0,
        percentage: status?.requestCount ? (status.requestCount / totalRequests) * 100 : 0,
        isHealthy: status?.isHealthy || false
      };
    });

    return {
      totalRequests,
      keyDistribution,
      healthyKeyCount: keyDistribution.filter(k => k.isHealthy).length,
      lastBalanceCheck: new Date()
    };
  }
}
```

### 6.2 è§†é¢‘ç”Ÿæˆæ¶æ„

#### ğŸ¬ è§†é¢‘ç”Ÿæˆæµç¨‹è®¾è®¡

**å®Œæ•´è§†é¢‘ç”Ÿæˆå·¥ä½œæµ**
```typescript
// è§†é¢‘ç”Ÿæˆå·¥ä½œæµç®¡ç†
export class VideoGenerationWorkflow {
  private readonly workflowConfig = {
    stages: ['validation', 'submission', 'processing', 'completion'],
    timeouts: {
      validation: 5000,    // 5ç§’
      submission: 30000,   // 30ç§’
      processing: 300000,  // 5åˆ†é’Ÿ
      completion: 10000    // 10ç§’
    },
    retryPolicy: {
      maxRetries: 3,
      backoffMultiplier: 2,
      initialDelay: 1000
    }
  };

  // ğŸš€ å¯åŠ¨è§†é¢‘ç”Ÿæˆå·¥ä½œæµ
  async startVideoGeneration(request: VideoWorkflowRequest): Promise<VideoWorkflowResponse> {
    const workflowId = `workflow_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    try {
      console.log(`ğŸ¬ å¯åŠ¨è§†é¢‘ç”Ÿæˆå·¥ä½œæµ: ${workflowId}`);
      
      // Stage 1: éªŒè¯é˜¶æ®µ
      await this.executeValidationStage(workflowId, request);
      
      // Stage 2: æäº¤é˜¶æ®µ
      const taskId = await this.executeSubmissionStage(workflowId, request);
      
      // Stage 3: å¤„ç†é˜¶æ®µï¼ˆå¼‚æ­¥ï¼‰
      this.scheduleProcessingStage(workflowId, taskId);
      
      return {
        success: true,
        workflowId,
        taskId,
        status: 'processing',
        estimatedCompletion: new Date(Date.now() + 90000) // 90ç§’é¢„ä¼°
      };

    } catch (error) {
      await this.handleWorkflowFailure(workflowId, error);
      throw error;
    }
  }

  // âœ… éªŒè¯é˜¶æ®µ
  private async executeValidationStage(workflowId: string, request: VideoWorkflowRequest): Promise<void> {
    console.log(`ğŸ” æ‰§è¡ŒéªŒè¯é˜¶æ®µ: ${workflowId}`);
    
    // 1. ç”¨æˆ·æƒé™éªŒè¯
    await this.validateUserPermissions(request.userId);
    
    // 2. ç§¯åˆ†ä½™é¢éªŒè¯
    await this.validateCreditBalance(request.userId);
    
    // 3. è¯·æ±‚å‚æ•°éªŒè¯
    await this.validateRequestParameters(request);
    
    // 4. APIå¯†é’¥å¯ç”¨æ€§éªŒè¯
    await this.validateAPIKeyAvailability();
    
    console.log(`âœ… éªŒè¯é˜¶æ®µå®Œæˆ: ${workflowId}`);
  }

  // ğŸš€ æäº¤é˜¶æ®µ
  private async executeSubmissionStage(workflowId: string, request: VideoWorkflowRequest): Promise<string> {
    console.log(`ğŸ“¤ æ‰§è¡Œæäº¤é˜¶æ®µ: ${workflowId}`);
    
    return await db.$transaction(async (tx) => {
      // 1. åˆ›å»ºè§†é¢‘è®°å½•
      const video = await tx.video.create({
        data: {
          userId: request.userId,
          title: `ASMR Video - ${new Date().toLocaleString()}`,
          type: 'ASMR',
          prompt: request.prompt,
          status: 'initializing',
          creditsUsed: CREDITS_CONFIG.VIDEO_COST
        }
      });

      // 2. è°ƒç”¨Veo3 API
      const veo3Service = new Veo3IntegrationService();
      const apiResult = await veo3Service.generateVideo({
        prompt: request.prompt,
        aspectRatio: request.aspectRatio,
        duration: request.duration
      });

      // 3. æ›´æ–°è§†é¢‘è®°å½•
      await tx.video.update({
        where: { id: video.id },
        data: {
          taskId: apiResult.taskId,
          status: 'processing'
        }
      });

      // 4. æ‰£é™¤ç§¯åˆ†
      await tx.user.update({
        where: { id: request.userId },
        data: {
          usedCredits: { increment: CREDITS_CONFIG.VIDEO_COST }
        }
      });

      console.log(`âœ… æäº¤é˜¶æ®µå®Œæˆ: ${workflowId}, TaskID: ${apiResult.taskId}`);
      return apiResult.taskId;
    });
  }

  // ğŸ”„ å¤„ç†é˜¶æ®µï¼ˆå¼‚æ­¥ç›‘æ§ï¼‰
  private scheduleProcessingStage(workflowId: string, taskId: string): void {
    console.log(`â° å®‰æ’å¤„ç†é˜¶æ®µç›‘æ§: ${workflowId}`);
    
    // å¼‚æ­¥ç›‘æ§ä»»åŠ¡çŠ¶æ€
    this.monitorTaskProgress(workflowId, taskId);
  }

  // ğŸ“Š ä»»åŠ¡è¿›åº¦ç›‘æ§
  private async monitorTaskProgress(workflowId: string, taskId: string): Promise<void> {
    const maxMonitorTime = 300000; // 5åˆ†é’Ÿæœ€å¤§ç›‘æ§æ—¶é—´
    const checkInterval = 10000;   // 10ç§’æ£€æŸ¥é—´éš”
    const startTime = Date.now();

    const monitor = setInterval(async () => {
      try {
        // æ£€æŸ¥æ˜¯å¦è¶…æ—¶
        if (Date.now() - startTime > maxMonitorTime) {
          clearInterval(monitor);
          await this.handleProcessingTimeout(workflowId, taskId);
          return;
        }

        // æŸ¥è¯¢ä»»åŠ¡çŠ¶æ€
        const veo3Service = new Veo3IntegrationService();
        const statusResult = await veo3Service.queryVideoStatus(taskId);

        if (statusResult.status === 'completed') {
          clearInterval(monitor);
          await this.completeVideoGeneration(workflowId, taskId, statusResult);
        } else if (statusResult.status === 'failed') {
          clearInterval(monitor);
          await this.handleVideoGenerationFailure(workflowId, taskId);
        }

      } catch (error) {
        console.error(`ç›‘æ§ä»»åŠ¡å¤±è´¥ ${workflowId}:`, error);
        // ç»§ç»­ç›‘æ§ï¼Œä½†è®°å½•é”™è¯¯
      }
    }, checkInterval);
  }

  // âœ… å®Œæˆè§†é¢‘ç”Ÿæˆ
  private async completeVideoGeneration(workflowId: string, taskId: string, result: VideoStatusResponse): Promise<void> {
    try {
      console.log(`ğŸ‰ è§†é¢‘ç”Ÿæˆå®Œæˆ: ${workflowId}`);
      
      // æ›´æ–°æ•°æ®åº“
      await db.video.update({
        where: { taskId },
        data: {
          status: 'completed',
          videoUrl: result.videoUrl,
          videoUrl1080p: result.videoUrl1080p,
          thumbnailUrl: result.thumbnailUrl,
          completedAt: new Date()
        }
      });

      // è®°å½•æˆåŠŸæ—¥å¿—
      await this.logWorkflowCompletion(workflowId, taskId);
      
      console.log(`âœ… å·¥ä½œæµå®Œæˆ: ${workflowId}`);
    } catch (error) {
      console.error(`å®Œæˆè§†é¢‘ç”Ÿæˆå¤±è´¥ ${workflowId}:`, error);
    }
  }
}
```

### 6.3 å†…å®¹ç®¡ç†

#### ğŸ¥ è§†é¢‘å­˜å‚¨ç­–ç•¥

**å¤šå±‚æ¬¡å†…å®¹å­˜å‚¨æ¶æ„**
```typescript
// è§†é¢‘å†…å®¹ç®¡ç†ç³»ç»Ÿ
export class VideoContentManager {
  private readonly storageConfig = {
    providers: {
      primary: 'cloudinary',     // ä¸»è¦å­˜å‚¨
      backup: 'aws_s3',          // å¤‡ä»½å­˜å‚¨
      cdn: 'cloudflare'          // CDNåŠ é€Ÿ
    },
    qualities: {
      standard: '720p',
      hd: '1080p',
      thumbnail: '360p'
    },
    formats: {
      video: ['mp4', 'webm'],
      image: ['jpg', 'webp']
    },
    retention: {
      active: 90,      // 90å¤©æ´»è·ƒæœŸ
      archive: 365,    // 1å¹´å½’æ¡£æœŸ
      deletion: 1095   // 3å¹´ååˆ é™¤
    }
  };

  // ğŸ“¥ è§†é¢‘å†…å®¹å¤„ç†
  async processVideoContent(taskId: string, videoUrls: VideoUrls): Promise<ProcessedVideo> {
    try {
      console.log(`ğŸ¥ å¼€å§‹å¤„ç†è§†é¢‘å†…å®¹: ${taskId}`);
      
      // 1. ä¸‹è½½åŸå§‹è§†é¢‘
      const originalVideo = await this.downloadVideo(videoUrls.videoUrl);
      const hdVideo = videoUrls.videoUrl1080p ? 
        await this.downloadVideo(videoUrls.videoUrl1080p) : null;
      
      // 2. ç”Ÿæˆç¼©ç•¥å›¾
      const thumbnail = await this.generateThumbnail(originalVideo);
      
      // 3. ä¼˜åŒ–è§†é¢‘æ ¼å¼
      const optimizedVersions = await this.optimizeVideoFormats(originalVideo, hdVideo);
      
      // 4. ä¸Šä¼ åˆ°å­˜å‚¨æœåŠ¡
      const storedUrls = await this.uploadToStorage(taskId, optimizedVersions, thumbnail);
      
      // 5. æ›´æ–°æ•°æ®åº“è®°å½•
      await this.updateVideoRecord(taskId, storedUrls);
      
      return {
        taskId,
        urls: storedUrls,
        processing: {
          duration: optimizedVersions.duration,
          fileSize: optimizedVersions.fileSize,
          resolution: optimizedVersions.resolution
        },
        status: 'completed'
      };

    } catch (error) {
      console.error(`è§†é¢‘å†…å®¹å¤„ç†å¤±è´¥ ${taskId}:`, error);
      throw error;
    }
  }

  // ğŸ–¼ï¸ æ™ºèƒ½ç¼©ç•¥å›¾ç”Ÿæˆ
  private async generateThumbnail(videoBuffer: Buffer): Promise<Buffer> {
    try {
      // ä½¿ç”¨FFmpegæå–å…³é”®å¸§
      const thumbnail = await this.extractKeyFrame(videoBuffer, {
        timestamp: '00:00:02', // 2ç§’å¤„æˆªå›¾
        size: '320x180',       // 16:9æ¯”ä¾‹ç¼©ç•¥å›¾
        quality: 85
      });

      return thumbnail;
    } catch (error) {
      console.error('ç¼©ç•¥å›¾ç”Ÿæˆå¤±è´¥:', error);
      // è¿”å›é»˜è®¤ç¼©ç•¥å›¾
      return await this.getDefaultThumbnail();
    }
  }

  // ğŸ”„ å†…å®¹ç”Ÿå‘½å‘¨æœŸç®¡ç†
  async manageContentLifecycle(): Promise<LifecycleReport> {
    try {
      console.log('ğŸ”„ æ‰§è¡Œå†…å®¹ç”Ÿå‘½å‘¨æœŸç®¡ç†');
      
      const report: LifecycleReport = {
        processed: 0,
        archived: 0,
        deleted: 0,
        errors: []
      };

      // 1. å½’æ¡£æ—§å†…å®¹
      const archiveResult = await this.archiveOldContent();
      report.archived = archiveResult.count;

      // 2. åˆ é™¤è¿‡æœŸå†…å®¹
      const deleteResult = await this.deleteExpiredContent();
      report.deleted = deleteResult.count;

      // 3. ä¼˜åŒ–å­˜å‚¨ä½¿ç”¨
      const optimizeResult = await this.optimizeStorageUsage();
      report.processed = optimizeResult.count;

      console.log('âœ… å†…å®¹ç”Ÿå‘½å‘¨æœŸç®¡ç†å®Œæˆ', report);
      return report;

    } catch (error) {
      console.error('å†…å®¹ç”Ÿå‘½å‘¨æœŸç®¡ç†å¤±è´¥:', error);
      throw error;
    }
  }

  // ğŸ“Š å†…å®¹åˆ†æä¸ä¼˜åŒ–
  async analyzeContentPerformance(): Promise<ContentAnalytics> {
    const analytics = await db.video.aggregate({
      _count: { id: true },
      _avg: { creditsUsed: true },
      _sum: { creditsUsed: true },
      where: {
        status: 'completed',
        createdAt: {
          gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000) // æœ€è¿‘30å¤©
        }
      }
    });

    const popularTypes = await db.video.groupBy({
      by: ['type'],
      _count: { id: true },
      where: {
        status: 'completed',
        createdAt: {
          gte: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000)
        }
      },
      orderBy: {
        _count: { id: 'desc' }
      },
      take: 5
    });

    return {
      totalVideos: analytics._count.id || 0,
      averageCreditsUsed: analytics._avg.creditsUsed || 0,
      totalCreditsConsumed: analytics._sum.creditsUsed || 0,
      popularTypes: popularTypes.map(type => ({
        type: type.type,
        count: type._count.id
      })),
      generatedAt: new Date()
    };
  }
}
```

---

## ğŸš€ ç¬¬ä¸ƒéƒ¨åˆ†ï¼šéƒ¨ç½²ä¸è¿ç»´æ¶æ„

### 7.1 åŒå¹³å°éƒ¨ç½²ç­–ç•¥

#### ğŸŒ Cloudflare Pagesä¸»éƒ¨ç½²

**å…¨çƒCDNæ™ºèƒ½éƒ¨ç½²**
```typescript
// Cloudflare Pageséƒ¨ç½²é…ç½®
export const CloudflareDeploymentConfig = {
  // ğŸŒ å…¨çƒè¾¹ç¼˜èŠ‚ç‚¹åˆ†å¸ƒ
  edgeLocations: {
    primary: ['é¦™æ¸¯', 'æ–°åŠ å¡', 'ä¸œäº¬', 'æ´›æ‰çŸ¶'],
    secondary: ['ä¼¦æ•¦', 'æ³•å…°å…‹ç¦', 'æ‚‰å°¼', 'åœ£ä¿ç½—'],
    coverage: 'å…¨çƒ200+åŸå¸‚'
  },

  // âš¡ æ€§èƒ½ä¼˜åŒ–é…ç½®
  performance: {
    caching: {
      static: '365d',      // é™æ€èµ„æºç¼“å­˜1å¹´
      api: '5m',           // APIå“åº”ç¼“å­˜5åˆ†é’Ÿ
      html: '1h'           // HTMLé¡µé¢ç¼“å­˜1å°æ—¶
    },
    compression: {
      gzip: true,
      brotli: true,
      minification: true
    },
    optimization: {
      imageOptimization: true,
      fontSubsetting: true,
      cssMinification: true,
      jsMinification: true
    }
  },

  // ğŸ”§ æ„å»ºé…ç½®
  buildSettings: {
    buildCommand: 'npm run build',
    outputDirectory: '.next',
    nodeVersion: '18.17.0',
    environmentVariables: {
      NODE_ENV: 'production',
      NEXT_PUBLIC_APP_URL: 'https://cuttingasmr.org',
      DATABASE_URL: '[ä»ç¯å¢ƒå˜é‡è·å–]',
      CLERK_SECRET_KEY: '[ä»ç¯å¢ƒå˜é‡è·å–]',
      VEO3_API_KEY: '[ä»ç¯å¢ƒå˜é‡è·å–]',
      CREEM_API_KEY: '[ä»ç¯å¢ƒå˜é‡è·å–]'
    }
  },

  // ğŸ›¡ï¸ å®‰å…¨é…ç½®
  security: {
    https: {
      enforced: true,
      hsts: {
        enabled: true,
        maxAge: 31536000,
        includeSubDomains: true,
        preload: true
      }
    },
    waf: {
      enabled: true,
      rules: ['OWASP_Top_10', 'DDoS_Protection', 'Rate_Limiting']
    },
    bot: {
      protection: true,
      allowedBots: ['Googlebot', 'Bingbot', 'Baiduspider']
    }
  }
};

// éƒ¨ç½²è‡ªåŠ¨åŒ–è„šæœ¬
export class CloudflareDeploymentManager {
  // ğŸš€ è‡ªåŠ¨éƒ¨ç½²æµç¨‹
  async deployToCloudflare(deploymentConfig: DeploymentConfig): Promise<DeploymentResult> {
    try {
      console.log('ğŸš€ å¼€å§‹Cloudflare Pageséƒ¨ç½²');
      
      // 1. é¢„éƒ¨ç½²æ£€æŸ¥
      await this.preDeploymentCheck(deploymentConfig);
      
      // 2. æ„å»ºé¡¹ç›®
      const buildResult = await this.buildProject(deploymentConfig);
      
      // 3. éƒ¨ç½²åˆ°Cloudflare
      const deployResult = await this.pushToCloudflare(buildResult);
      
      // 4. éƒ¨ç½²åéªŒè¯
      await this.postDeploymentValidation(deployResult);
      
      // 5. æ›´æ–°åŸŸåé…ç½®
      await this.updateDNSConfiguration(deployResult);
      
      return {
        success: true,
        deploymentId: deployResult.id,
        url: deployResult.url,
        timestamp: new Date(),
        buildTime: buildResult.duration,
        deployTime: deployResult.duration
      };

    } catch (error) {
      console.error('Cloudflareéƒ¨ç½²å¤±è´¥:', error);
      await this.handleDeploymentFailure(error);
      throw error;
    }
  }

  // ğŸ” éƒ¨ç½²å¥åº·æ£€æŸ¥
  async performHealthCheck(url: string): Promise<HealthCheckResult> {
    const checks = [
      { name: 'é¦–é¡µåŠ è½½', test: () => this.checkPageLoad(url) },
      { name: 'APIå¥åº·', test: () => this.checkAPIHealth(`${url}/api/health`) },
      { name: 'æ•°æ®åº“è¿æ¥', test: () => this.checkDatabaseConnection(`${url}/api/check-env`) },
      { name: 'æ”¯ä»˜ç³»ç»Ÿ', test: () => this.checkPaymentSystem(`${url}/api/test-creem`) },
      { name: 'AIæœåŠ¡', test: () => this.checkAIService(`${url}/api/veo3-key-status`) }
    ];

    const results = await Promise.allSettled(
      checks.map(async check => ({
        name: check.name,
        status: await check.test(),
        timestamp: new Date()
      }))
    );

    return {
      overallHealth: results.every(r => r.status === 'fulfilled'),
      checks: results.map(r => r.status === 'fulfilled' ? r.value : {
        name: 'unknown',
        status: false,
        error: r.reason
      }),
      checkedAt: new Date()
    };
  }
}
```

#### ğŸš‚ Railwayå¤‡ç”¨éƒ¨ç½²

**é«˜å¯ç”¨å¤‡ç”¨éƒ¨ç½²ç­–ç•¥**
```typescript
// Railwayå¤‡ç”¨éƒ¨ç½²é…ç½®
export const RailwayDeploymentConfig = {
  // ğŸ›¤ï¸ Railwayç‰¹å®šé…ç½®
  platform: {
    runtime: 'Node.js 18',
    memory: '512MB',
    cpu: '0.5 vCPU',
    storage: '1GB SSD',
    region: 'us-west1'
  },

  // ğŸ”„ è‡ªåŠ¨å¤‡ç”¨åˆ‡æ¢
  failover: {
    healthCheckInterval: 30000,  // 30ç§’æ£€æŸ¥ä¸€æ¬¡
    failureThreshold: 3,         // 3æ¬¡å¤±è´¥ååˆ‡æ¢
    recoveryCheckInterval: 60000, // 1åˆ†é’Ÿæ£€æŸ¥æ¢å¤
    autoSwitchBack: true         // ä¸»æœåŠ¡æ¢å¤åè‡ªåŠ¨åˆ‡å›
  },

  // ğŸ“Š ç›‘æ§é…ç½®
  monitoring: {
    uptime: true,
    performance: true,
    errors: true,
    alerts: {
      email: 'admin@cuttingasmr.org',
      webhook: 'https://hooks.slack.com/webhook'
    }
  }
};

// æ™ºèƒ½æµé‡åˆ‡æ¢ç³»ç»Ÿ
export class IntelligentTrafficSwitcher {
  private readonly switcherConfig = {
    primaryEndpoint: 'https://cuttingasmr.org',
    backupEndpoint: 'https://backup.cuttingasmr.org',
    healthCheckTimeout: 5000,
    switchThreshold: 3 // è¿ç»­3æ¬¡å¤±è´¥ååˆ‡æ¢
  };

  private failureCount = 0;
  private currentEndpoint = this.switcherConfig.primaryEndpoint;
  private isUsingBackup = false;

  // ğŸ”„ è‡ªåŠ¨æ•…éšœè½¬ç§»
  async performAutomaticFailover(): Promise<FailoverResult> {
    try {
      console.log('ğŸ” æ£€æŸ¥ä¸»æœåŠ¡å¥åº·çŠ¶æ€');
      
      // æ£€æŸ¥ä¸»æœåŠ¡
      const primaryHealthy = await this.checkEndpointHealth(this.switcherConfig.primaryEndpoint);
      
      if (!primaryHealthy) {
        this.failureCount++;
        console.log(`âš ï¸ ä¸»æœåŠ¡æ£€æŸ¥å¤±è´¥ ${this.failureCount}/${this.switcherConfig.switchThreshold}`);
        
        if (this.failureCount >= this.switcherConfig.switchThreshold && !this.isUsingBackup) {
          // åˆ‡æ¢åˆ°å¤‡ç”¨æœåŠ¡
          await this.switchToBackup();
          return {
            switched: true,
            from: 'primary',
            to: 'backup',
            reason: 'primary_service_failure',
            timestamp: new Date()
          };
        }
      } else {
        // ä¸»æœåŠ¡æ¢å¤ï¼Œé‡ç½®å¤±è´¥è®¡æ•°
        this.failureCount = 0;
        
        if (this.isUsingBackup) {
          // åˆ‡æ¢å›ä¸»æœåŠ¡
          await this.switchToPrimary();
          return {
            switched: true,
            from: 'backup',
            to: 'primary',
            reason: 'primary_service_recovered',
            timestamp: new Date()
          };
        }
      }

      return {
        switched: false,
        currentEndpoint: this.currentEndpoint,
        isUsingBackup: this.isUsingBackup,
        timestamp: new Date()
      };

    } catch (error) {
      console.error('æ•…éšœè½¬ç§»æ£€æŸ¥å¤±è´¥:', error);
      throw error;
    }
  }

  // ğŸ”„ åˆ‡æ¢åˆ°å¤‡ç”¨æœåŠ¡
  private async switchToBackup(): Promise<void> {
    console.log('ğŸ”„ åˆ‡æ¢åˆ°å¤‡ç”¨æœåŠ¡');
    
    // æ›´æ–°DNSæŒ‡å‘
    await this.updateDNSRecord('backup.cuttingasmr.org');
    
    // æ›´æ–°CDNé…ç½®
    await this.updateCDNOrigin('backup.cuttingasmr.org');
    
    // å‘é€å‘Šè­¦é€šçŸ¥
    await this.sendFailoverAlert('switched_to_backup');
    
    this.currentEndpoint = this.switcherConfig.backupEndpoint;
    this.isUsingBackup = true;
    this.failureCount = 0;
  }

  // ğŸ  åˆ‡æ¢å›ä¸»æœåŠ¡
  private async switchToPrimary(): Promise<void> {
    console.log('ğŸ  åˆ‡æ¢å›ä¸»æœåŠ¡');
    
    // éªŒè¯ä¸»æœåŠ¡å®Œå…¨æ¢å¤
    const isStable = await this.verifyServiceStability(this.switcherConfig.primaryEndpoint);
    
    if (isStable) {
      // æ›´æ–°DNSæŒ‡å‘
      await this.updateDNSRecord('cuttingasmr.org');
      
      // æ›´æ–°CDNé…ç½®
      await this.updateCDNOrigin('cuttingasmr.org');
      
      // å‘é€æ¢å¤é€šçŸ¥
      await this.sendFailoverAlert('switched_to_primary');
      
      this.currentEndpoint = this.switcherConfig.primaryEndpoint;
      this.isUsingBackup = false;
    }
  }
}
```

### 7.2 è¿ç»´ç›‘æ§ä½“ç³»

#### ğŸ“Š ç³»ç»Ÿç›‘æ§æ¶æ„

**å…¨æ–¹ä½ç›‘æ§ç³»ç»Ÿ**
```typescript
// ç³»ç»Ÿç›‘æ§æœåŠ¡
export class SystemMonitoringService {
  private readonly monitoringConfig = {
    metrics: {
      system: ['cpu', 'memory', 'disk', 'network'],
      application: ['response_time', 'error_rate', 'throughput', 'uptime'],
      business: ['video_generation', 'payment_success', 'user_activity'],
      ai: ['api_key_health', 'generation_success_rate', 'average_processing_time']
    },
    intervals: {
      realtime: 5000,    // 5ç§’å®æ—¶ç›‘æ§
      regular: 60000,    // 1åˆ†é’Ÿå¸¸è§„ç›‘æ§
      detailed: 300000   // 5åˆ†é’Ÿè¯¦ç»†ç›‘æ§
    },
    thresholds: {
      cpu: 80,           // CPUä½¿ç”¨ç‡é˜ˆå€¼
      memory: 85,        // å†…å­˜ä½¿ç”¨ç‡é˜ˆå€¼
      responseTime: 2000, // å“åº”æ—¶é—´é˜ˆå€¼(ms)
      errorRate: 5       // é”™è¯¯ç‡é˜ˆå€¼(%)
    }
  };

  // ğŸ“ˆ å®æ—¶æ€§èƒ½ç›‘æ§
  async collectPerformanceMetrics(): Promise<PerformanceMetrics> {
    try {
      const startTime = Date.now();
      
      // æ”¶é›†ç³»ç»ŸæŒ‡æ ‡
      const systemMetrics = await this.collectSystemMetrics();
      
      // æ”¶é›†åº”ç”¨æŒ‡æ ‡
      const applicationMetrics = await this.collectApplicationMetrics();
      
      // æ”¶é›†ä¸šåŠ¡æŒ‡æ ‡
      const businessMetrics = await this.collectBusinessMetrics();
      
      // æ”¶é›†AIæœåŠ¡æŒ‡æ ‡
      const aiMetrics = await this.collectAIMetrics();
      
      const collectionTime = Date.now() - startTime;
      
      return {
        timestamp: new Date(),
        system: systemMetrics,
        application: applicationMetrics,
        business: businessMetrics,
        ai: aiMetrics,
        collection: {
          duration: collectionTime,
          metricsCount: this.getTotalMetricsCount(systemMetrics, applicationMetrics, businessMetrics, aiMetrics)
        }
      };

    } catch (error) {
      console.error('æ€§èƒ½æŒ‡æ ‡æ”¶é›†å¤±è´¥:', error);
      throw error;
    }
  }

  // ğŸš¨ æ™ºèƒ½å‘Šè­¦ç³»ç»Ÿ
  async evaluateAlerts(metrics: PerformanceMetrics): Promise<AlertEvaluation> {
    const alerts: Alert[] = [];
    
    // ç³»ç»Ÿå‘Šè­¦æ£€æŸ¥
    if (metrics.system.cpu > this.monitoringConfig.thresholds.cpu) {
      alerts.push({
        level: 'warning',
        type: 'system',
        message: `CPUä½¿ç”¨ç‡è¿‡é«˜: ${metrics.system.cpu}%`,
        threshold: this.monitoringConfig.thresholds.cpu,
        currentValue: metrics.system.cpu,
        timestamp: new Date()
      });
    }

    // åº”ç”¨å‘Šè­¦æ£€æŸ¥
    if (metrics.application.responseTime > this.monitoringConfig.thresholds.responseTime) {
      alerts.push({
        level: 'error',
        type: 'application',
        message: `å“åº”æ—¶é—´è¿‡é•¿: ${metrics.application.responseTime}ms`,
        threshold: this.monitoringConfig.thresholds.responseTime,
        currentValue: metrics.application.responseTime,
        timestamp: new Date()
      });
    }

    // ä¸šåŠ¡å‘Šè­¦æ£€æŸ¥
    if (metrics.business.videoGenerationSuccessRate < 90) {
      alerts.push({
        level: 'critical',
        type: 'business',
        message: `è§†é¢‘ç”ŸæˆæˆåŠŸç‡è¿‡ä½: ${metrics.business.videoGenerationSuccessRate}%`,
        threshold: 90,
        currentValue: metrics.business.videoGenerationSuccessRate,
        timestamp: new Date()
      });
    }

    // AIæœåŠ¡å‘Šè­¦æ£€æŸ¥
    if (metrics.ai.healthyKeysCount === 0) {
      alerts.push({
        level: 'critical',
        type: 'ai',
        message: 'æ‰€æœ‰APIå¯†é’¥ä¸å¯ç”¨',
        threshold: 1,
        currentValue: 0,
        timestamp: new Date()
      });
    }

    // å‘é€å‘Šè­¦
    if (alerts.length > 0) {
      await this.sendAlerts(alerts);
    }

    return {
      alertsGenerated: alerts.length,
      alerts,
      evaluatedAt: new Date()
    };
  }

  // ğŸ“Š æ€§èƒ½åˆ†ææŠ¥å‘Š
  async generatePerformanceReport(timeRange: TimeRange): Promise<PerformanceReport> {
    const historicalData = await this.getHistoricalMetrics(timeRange);
    
    return {
      period: timeRange,
      summary: {
        averageResponseTime: this.calculateAverage(historicalData, 'responseTime'),
        totalRequests: this.calculateSum(historicalData, 'requests'),
        errorRate: this.calculateAverage(historicalData, 'errorRate'),
        uptime: this.calculateUptime(historicalData)
      },
      trends: {
        responseTimeTrend: this.analyzeTrend(historicalData, 'responseTime'),
        errorRateTrend: this.analyzeTrend(historicalData, 'errorRate'),
        throughputTrend: this.analyzeTrend(historicalData, 'throughput')
      },
      recommendations: await this.generateRecommendations(historicalData),
      generatedAt: new Date()
    };
  }
}
```

#### ğŸ”§ è‡ªåŠ¨åŒ–è¿ç»´

**æ™ºèƒ½è¿ç»´è‡ªåŠ¨åŒ–ç³»ç»Ÿ**
```typescript
// è‡ªåŠ¨åŒ–è¿ç»´æœåŠ¡
export class AutomatedOperationsService {
  private readonly automationConfig = {
    selfHealing: {
      enabled: true,
      maxAttempts: 3,
      cooldownPeriod: 300000 // 5åˆ†é’Ÿå†·å´æœŸ
    },
    maintenance: {
      scheduledHours: [2, 3, 4], // å‡Œæ™¨2-4ç‚¹ç»´æŠ¤çª—å£
      autoUpdateEnabled: true,
      backupBeforeMaintenance: true
    },
    scaling: {
      enabled: false, // Cloudflareè‡ªåŠ¨æ‰©å±•
      metrics: ['cpu', 'memory', 'requests'],
      thresholds: { scale_up: 80, scale_down: 30 }
    }
  };

  // ğŸ©º è‡ªæ„ˆç³»ç»Ÿ
  async performSelfHealing(issue: SystemIssue): Promise<HealingResult> {
    try {
      console.log(`ğŸ©º å¼€å§‹è‡ªæ„ˆå¤„ç†: ${issue.type}`);
      
      const healingStrategy = this.selectHealingStrategy(issue);
      
      for (let attempt = 1; attempt <= this.automationConfig.selfHealing.maxAttempts; attempt++) {
        try {
          console.log(`ğŸ”„ ç¬¬ ${attempt} æ¬¡è‡ªæ„ˆå°è¯•`);
          
          const result = await this.executeHealingStrategy(healingStrategy, issue);
          
          if (result.success) {
            await this.logHealingSuccess(issue, result, attempt);
            return {
              success: true,
              strategy: healingStrategy.name,
              attempts: attempt,
              resolution: result.description,
              timestamp: new Date()
            };
          }
          
        } catch (healingError) {
          console.error(`ç¬¬ ${attempt} æ¬¡è‡ªæ„ˆå¤±è´¥:`, healingError);
          
          if (attempt === this.automationConfig.selfHealing.maxAttempts) {
            await this.escalateToManual(issue, healingError);
          }
        }
      }

      return {
        success: false,
        strategy: healingStrategy.name,
        attempts: this.automationConfig.selfHealing.maxAttempts,
        error: 'All healing attempts failed',
        escalated: true,
        timestamp: new Date()
      };

    } catch (error) {
      console.error('è‡ªæ„ˆç³»ç»Ÿé”™è¯¯:', error);
      throw error;
    }
  }

  // ğŸ”§ è‡ªåŠ¨ç»´æŠ¤ä»»åŠ¡
  async runMaintenanceTasks(): Promise<MaintenanceResult> {
    try {
      console.log('ğŸ”§ å¼€å§‹è‡ªåŠ¨ç»´æŠ¤ä»»åŠ¡');
      
      const tasks: MaintenanceTask[] = [
        { name: 'æ•°æ®åº“æ¸…ç†', action: () => this.cleanupDatabase() },
        { name: 'æ—¥å¿—å½’æ¡£', action: () => this.archiveLogs() },
        { name: 'ç¼“å­˜æ¸…ç†', action: () => this.clearExpiredCache() },
        { name: 'æ€§èƒ½ä¼˜åŒ–', action: () => this.optimizePerformance() },
        { name: 'å®‰å…¨æ‰«æ', action: () => this.performSecurityScan() }
      ];

      const results = await Promise.allSettled(
        tasks.map(async task => ({
          name: task.name,
          result: await task.action(),
          completedAt: new Date()
        }))
      );

      const successfulTasks = results.filter(r => r.status === 'fulfilled').length;
      const failedTasks = results.filter(r => r.status === 'rejected').length;

      return {
        totalTasks: tasks.length,
        successful: successfulTasks,
        failed: failedTasks,
        results: results.map(r => r.status === 'fulfilled' ? r.value : {
          name: 'unknown',
          error: r.reason,
          completedAt: new Date()
        }),
        completedAt: new Date()
      };

    } catch (error) {
      console.error('è‡ªåŠ¨ç»´æŠ¤ä»»åŠ¡å¤±è´¥:', error);
      throw error;
    }
  }

  // ğŸ“Š è¿ç»´ä»ªè¡¨æ¿æ•°æ®
  async getOperationsDashboard(): Promise<OperationsDashboard> {
    const [
      systemStatus,
      recentAlerts,
      performanceMetrics,
      deploymentStatus,
      maintenanceSchedule
    ] = await Promise.all([
      this.getSystemStatus(),
      this.getRecentAlerts(24), // æœ€è¿‘24å°æ—¶
      this.getCurrentPerformanceMetrics(),
      this.getDeploymentStatus(),
      this.getMaintenanceSchedule()
    ]);

    return {
      overview: {
        systemHealth: systemStatus.overall,
        activeAlerts: recentAlerts.filter(a => a.status === 'active').length,
        uptime: systemStatus.uptime,
        lastDeployment: deploymentStatus.lastDeployment
      },
      metrics: {
        responseTime: performanceMetrics.averageResponseTime,
        errorRate: performanceMetrics.errorRate,
        throughput: performanceMetrics.requestsPerSecond,
        resourceUsage: {
          cpu: performanceMetrics.cpu,
          memory: performanceMetrics.memory
        }
      },
      alerts: recentAlerts.slice(0, 10), // æœ€è¿‘10ä¸ªå‘Šè­¦
      maintenance: maintenanceSchedule.nextScheduled,
      generatedAt: new Date()
    };
  }
}
```

---

## ğŸ§ª ç¬¬å…«éƒ¨åˆ†ï¼šæµ‹è¯•æ¶æ„

### 8.1 å¤šå±‚æ¬¡æµ‹è¯•ç­–ç•¥

#### ğŸ§ª å•å…ƒæµ‹è¯•æ¡†æ¶

**ç»„ä»¶çº§æµ‹è¯•è®¾è®¡**
```typescript
// Jest + React Testing Libraryæµ‹è¯•é…ç½®
export const TestConfiguration = {
  frameworks: {
    unit: 'Jest',
    integration: 'Jest + Supertest',
    e2e: 'Playwright',
    performance: 'Lighthouse CI'
  },
  coverage: {
    threshold: 80,
    exclude: ['node_modules', '.next', 'coverage']
  },
  testEnvironments: {
    development: 'jsdom',
    integration: 'node',
    e2e: 'browser'
  }
};

// æ ¸å¿ƒä¸šåŠ¡é€»è¾‘æµ‹è¯•
describe('CreditManagementSystem', () => {
  let creditSystem: CreditManagementSystem;
  let mockDb: MockDatabase;

  beforeEach(() => {
    mockDb = new MockDatabase();
    creditSystem = new CreditManagementSystem(mockDb);
  });

  describe('validateAndConsumeCredits', () => {
    it('åº”è¯¥æˆåŠŸæ¶ˆè´¹è¶³å¤Ÿçš„ç§¯åˆ†', async () => {
      // Arrange
      const userId = 'test-user-id';
      const mockUser = {
        id: userId,
        totalCredits: 100,
        usedCredits: 20
      };
      mockDb.user.findUnique.mockResolvedValue(mockUser);

      // Act
      const result = await creditSystem.validateAndConsumeCredits(userId, 10, 'video_generation');

      // Assert
      expect(result.success).toBe(true);
      expect(result.consumed).toBe(10);
      expect(result.balanceAfter).toBe(70);
      expect(mockDb.user.update).toHaveBeenCalledWith({
        where: { id: userId },
        data: { usedCredits: { increment: 10 } }
      });
    });

    it('ç§¯åˆ†ä¸è¶³æ—¶åº”è¯¥æŠ›å‡ºé”™è¯¯', async () => {
      // Arrange
      const userId = 'test-user-id';
      const mockUser = {
        id: userId,
        totalCredits: 100,
        usedCredits: 95
      };
      mockDb.user.findUnique.mockResolvedValue(mockUser);

      // Act & Assert
      await expect(
        creditSystem.validateAndConsumeCredits(userId, 10, 'video_generation')
      ).rejects.toThrow('Insufficient credits');
    });
  });
});

// APIç«¯ç‚¹é›†æˆæµ‹è¯•
describe('APIé›†æˆæµ‹è¯•', () => {
  let app: NextApiRequest;
  let mockAuth: jest.Mock;

  beforeEach(() => {
    mockAuth = jest.fn();
    app = createTestApp({ auth: mockAuth });
  });

  describe('POST /api/generate-video', () => {
    it('åº”è¯¥æˆåŠŸç”Ÿæˆè§†é¢‘', async () => {
      // Mockè®¤è¯
      mockAuth.mockResolvedValue({ userId: 'test-user' });
      
      // Mockæ•°æ®åº“
      jest.spyOn(db.user, 'findUnique').mockResolvedValue({
        id: 'test-user',
        totalCredits: 100,
        usedCredits: 0
      });

      // Mock APIå¯†é’¥
      jest.spyOn(require('@/lib/api-key-pool'), 'getApiKey')
        .mockReturnValue('test-api-key');

      // Mockå¤–éƒ¨API
      global.fetch = jest.fn().mockResolvedValue({
        ok: true,
        json: () => Promise.resolve({
          code: 200,
          data: { task_id: 'test-task-id' }
        })
      });

      const response = await request(app)
        .post('/api/generate-video')
        .send({
          prompt: 'ä¸€ä¸ªæ”¾æ¾çš„ASMRåœºæ™¯',
          aspectRatio: '16:9',
          duration: '8'
        });

      expect(response.status).toBe(200);
      expect(response.body.success).toBe(true);
      expect(response.body.taskId).toBe('test-task-id');
    });
  });
});
```

#### ğŸ”„ ç«¯åˆ°ç«¯æµ‹è¯•

**å®Œæ•´ç”¨æˆ·æµç¨‹æµ‹è¯•**
```typescript
// Playwright E2Eæµ‹è¯•
import { test, expect } from '@playwright/test';

test.describe('ç”¨æˆ·å®Œæ•´æµç¨‹æµ‹è¯•', () => {
  test.beforeEach(async ({ page }) => {
    // è®¾ç½®æµ‹è¯•ç¯å¢ƒ
    await page.goto('/');
  });

  test('å®Œæ•´çš„è§†é¢‘ç”Ÿæˆæµç¨‹', async ({ page }) => {
    // 1. ç”¨æˆ·ç™»å½•
    await page.click('[data-testid="login-button"]');
    await page.fill('[data-testid="email-input"]', 'test@example.com');
    await page.fill('[data-testid="password-input"]', 'password123');
    await page.click('[data-testid="submit-login"]');
    
    // ç­‰å¾…ç™»å½•å®Œæˆ
    await expect(page.locator('[data-testid="user-profile"]')).toBeVisible();

    // 2. æ£€æŸ¥ç§¯åˆ†ä½™é¢
    const creditsText = await page.locator('[data-testid="credits-balance"]').textContent();
    expect(creditsText).toContain('ç§¯åˆ†');

    // 3. ç”Ÿæˆè§†é¢‘
    await page.click('[data-testid="generate-video-button"]');
    await page.fill('[data-testid="prompt-textarea"]', 'ä¸€ä¸ªå®‰é™çš„æ£®æ—åœºæ™¯ï¼Œé¸Ÿå„¿åœ¨æ­Œå”±');
    await page.selectOption('[data-testid="aspect-ratio-select"]', '16:9');
    await page.selectOption('[data-testid="duration-select"]', '8');
    
    // æäº¤ç”Ÿæˆè¯·æ±‚
    await page.click('[data-testid="start-generation"]');
    
    // 4. éªŒè¯ç”ŸæˆçŠ¶æ€
    await expect(page.locator('[data-testid="generation-status"]')).toContainText('å¤„ç†ä¸­');
    
    // 5. ç­‰å¾…ç”Ÿæˆå®Œæˆï¼ˆæˆ–è¶…æ—¶ï¼‰
    await page.waitForSelector('[data-testid="video-result"]', { timeout: 120000 });
    
    // 6. éªŒè¯è§†é¢‘ç»“æœ
    const videoElement = page.locator('[data-testid="generated-video"]');
    await expect(videoElement).toBeVisible();
    
    // 7. æ£€æŸ¥ç§¯åˆ†æ‰£é™¤
    const newCreditsText = await page.locator('[data-testid="credits-balance"]').textContent();
    // éªŒè¯ç§¯åˆ†å·²å‡å°‘
  });

  test('æ”¯ä»˜æµç¨‹æµ‹è¯•', async ({ page }) => {
    // 1. ç™»å½•
    await page.goto('/login');
    // ... ç™»å½•é€»è¾‘

    // 2. è¿›å…¥è´­ä¹°é¡µé¢
    await page.goto('/pricing');
    
    // 3. é€‰æ‹©ç§¯åˆ†åŒ…
    await page.click('[data-testid="starter-package"]');
    
    // 4. éªŒè¯æ”¯ä»˜é“¾æ¥
    const paymentLink = await page.locator('[data-testid="payment-link"]').getAttribute('href');
    expect(paymentLink).toContain('creem.io');
    
    // 5. æ¨¡æ‹Ÿæ”¯ä»˜æˆåŠŸï¼ˆé€šè¿‡webhookæµ‹è¯•ç«¯ç‚¹ï¼‰
    await page.goto('/api/simulate-webhook');
    // ... æ¨¡æ‹Ÿæ”¯ä»˜æˆåŠŸ
    
    // 6. éªŒè¯ç§¯åˆ†åˆ°è´¦
    await page.goto('/profile');
    const creditsBalance = await page.locator('[data-testid="credits-balance"]').textContent();
    expect(creditsBalance).toContain('115'); // StarteråŒ…ç§¯åˆ†
  });
});

// æ€§èƒ½æµ‹è¯•
test.describe('æ€§èƒ½æµ‹è¯•', () => {
  test('é¡µé¢åŠ è½½æ€§èƒ½', async ({ page }) => {
    const startTime = Date.now();
    
    await page.goto('/');
    await page.waitForLoadState('networkidle');
    
    const loadTime = Date.now() - startTime;
    expect(loadTime).toBeLessThan(3000); // 3ç§’å†…åŠ è½½å®Œæˆ
  });

  test('APIå“åº”æ€§èƒ½', async ({ page }) => {
    await page.goto('/');
    
    // ç›‘æ§APIè°ƒç”¨
    const apiResponse = page.waitForResponse('/api/credits');
    await page.click('[data-testid="check-credits"]');
    
    const response = await apiResponse;
    expect(response.status()).toBe(200);
    
    // éªŒè¯å“åº”æ—¶é—´
    const responseTime = response.timing();
    expect(responseTime).toBeLessThan(1000); // 1ç§’å†…å“åº”
  });
});
```

### 8.2 è‡ªåŠ¨åŒ–æµ‹è¯•æµç¨‹

#### ğŸš€ CI/CDæµ‹è¯•é›†æˆ

**æŒç»­æµ‹è¯•è‡ªåŠ¨åŒ–**
```typescript
// GitHub Actionsæµ‹è¯•å·¥ä½œæµ
export const TestWorkflow = `
name: è‡ªåŠ¨åŒ–æµ‹è¯•æµç¨‹

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  unit-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
      
      - name: å®‰è£…ä¾èµ–
        run: npm ci
      
      - name: è¿è¡Œå•å…ƒæµ‹è¯•
        run: npm run test:unit -- --coverage
      
      - name: ä¸Šä¼ è¦†ç›–ç‡æŠ¥å‘Š
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage/lcov.info

  integration-tests:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:13
        env:
          POSTGRES_PASSWORD: postgres
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
      
      - name: å®‰è£…ä¾èµ–
        run: npm ci
      
      - name: è¿è¡Œæ•°æ®åº“è¿ç§»
        run: npx prisma migrate deploy
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test
      
      - name: è¿è¡Œé›†æˆæµ‹è¯•
        run: npm run test:integration
        env:
          DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test

  e2e-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
      
      - name: å®‰è£…ä¾èµ–
        run: npm ci
      
      - name: å®‰è£…Playwright
        run: npx playwright install --with-deps
      
      - name: æ„å»ºåº”ç”¨
        run: npm run build
      
      - name: å¯åŠ¨åº”ç”¨
        run: npm start &
        env:
          NODE_ENV: test
      
      - name: è¿è¡ŒE2Eæµ‹è¯•
        run: npx playwright test
      
      - name: ä¸Šä¼ æµ‹è¯•æŠ¥å‘Š
        uses: actions/upload-artifact@v3
        if: always()
        with:
          name: playwright-report
          path: playwright-report/
`;

// æµ‹è¯•æ•°æ®ç®¡ç†
export class TestDataManager {
  private readonly testDataConfig = {
    users: {
      testUser: {
        email: 'test@example.com',
        totalCredits: 100,
        usedCredits: 0
      },
      premiumUser: {
        email: 'premium@example.com',
        totalCredits: 1000,
        usedCredits: 100
      }
    },
    videos: {
      completedVideo: {
        status: 'completed',
        taskId: 'test-task-123',
        videoUrl: 'https://example.com/video.mp4'
      }
    }
  };

  // ğŸ—„ï¸ è®¾ç½®æµ‹è¯•æ•°æ®
  async setupTestData(): Promise<void> {
    try {
      console.log('ğŸ—„ï¸ è®¾ç½®æµ‹è¯•æ•°æ®');
      
      // æ¸…ç†ç°æœ‰æµ‹è¯•æ•°æ®
      await this.cleanupTestData();
      
      // åˆ›å»ºæµ‹è¯•ç”¨æˆ·
      await this.createTestUsers();
      
      // åˆ›å»ºæµ‹è¯•è§†é¢‘
      await this.createTestVideos();
      
      // åˆ›å»ºæµ‹è¯•æ”¯ä»˜è®°å½•
      await this.createTestPurchases();
      
      console.log('âœ… æµ‹è¯•æ•°æ®è®¾ç½®å®Œæˆ');
    } catch (error) {
      console.error('æµ‹è¯•æ•°æ®è®¾ç½®å¤±è´¥:', error);
      throw error;
    }
  }

  // ğŸ§¹ æ¸…ç†æµ‹è¯•æ•°æ®
  async cleanupTestData(): Promise<void> {
    try {
      console.log('ğŸ§¹ æ¸…ç†æµ‹è¯•æ•°æ®');
      
      // åˆ é™¤æµ‹è¯•ç”¨æˆ·åŠç›¸å…³æ•°æ®
      await db.user.deleteMany({
        where: {
          email: {
            contains: 'test'
          }
        }
      });
      
      // åˆ é™¤æµ‹è¯•è§†é¢‘
      await db.video.deleteMany({
        where: {
          taskId: {
            startsWith: 'test-'
          }
        }
      });
      
      console.log('âœ… æµ‹è¯•æ•°æ®æ¸…ç†å®Œæˆ');
    } catch (error) {
      console.error('æµ‹è¯•æ•°æ®æ¸…ç†å¤±è´¥:', error);
      throw error;
    }
  }

  // ğŸ­ æ¨¡æ‹Ÿå¤–éƒ¨æœåŠ¡
  createMockServices(): MockServices {
    return {
      // æ¨¡æ‹ŸClerkè®¤è¯
      mockClerkAuth: jest.fn().mockResolvedValue({
        userId: 'test-user-id',
        sessionId: 'test-session-id'
      }),
      
      // æ¨¡æ‹ŸVeo3 API
      mockVeo3API: jest.fn().mockImplementation((endpoint) => {
        if (endpoint.includes('generate')) {
          return Promise.resolve({
            ok: true,
            json: () => Promise.resolve({
              code: 200,
              data: { task_id: 'test-task-id' }
            })
          });
        }
        if (endpoint.includes('record-info')) {
          return Promise.resolve({
            ok: true,
            json: () => Promise.resolve({
              code: 200,
              data: {
                status: 'completed',
                video_url: 'https://example.com/video.mp4'
              }
            })
          });
        }
      }),
      
      // æ¨¡æ‹ŸCreemæ”¯ä»˜
      mockCreemPayment: jest.fn().mockResolvedValue({
        paymentUrl: 'https://test.creem.io/payment/test-product-id'
      })
    };
  }
}
```

---

## ğŸ“Š ç¬¬ä¹éƒ¨åˆ†ï¼šæ•°æ®åˆ†æä¸ç›‘æ§æ¶æ„

### 9.1 ä¸šåŠ¡æ•°æ®åˆ†æ

#### ğŸ“ˆ æ ¸å¿ƒæŒ‡æ ‡ä½“ç³»

**ä¸šåŠ¡å…³é”®æŒ‡æ ‡(KPI)ç›‘æ§**
```typescript
// ä¸šåŠ¡æŒ‡æ ‡åˆ†æç³»ç»Ÿ
export class BusinessAnalyticsService {
  private readonly kpiConfig = {
    // ğŸ“Š æ ¸å¿ƒä¸šåŠ¡æŒ‡æ ‡
    coreMetrics: {
      userGrowth: {
        dailyActiveUsers: 'DAU',
        monthlyActiveUsers: 'MAU',
        userRetentionRate: 'ç”¨æˆ·ç•™å­˜ç‡',
        newUserConversion: 'æ–°ç”¨æˆ·è½¬åŒ–ç‡'
      },
      revenue: {
        monthlyRecurringRevenue: 'MRR',
        averageRevenuePerUser: 'ARPU',
        customerLifetimeValue: 'CLV',
        paymentSuccessRate: 'æ”¯ä»˜æˆåŠŸç‡'
      },
      product: {
        videoGenerationRate: 'è§†é¢‘ç”Ÿæˆç‡',
        videoSuccessRate: 'è§†é¢‘æˆåŠŸç‡',
        averageProcessingTime: 'å¹³å‡å¤„ç†æ—¶é—´',
        creditUtilizationRate: 'ç§¯åˆ†ä½¿ç”¨ç‡'
      }
    },
    // ğŸ“… æŠ¥å‘Šé¢‘ç‡
    reportingFrequency: {
      realtime: 'dashboard',
      daily: 'operations',
      weekly: 'management',
      monthly: 'executives'
    }
  };

  // ğŸ“Š ç”Ÿæˆä¸šåŠ¡ä»ªè¡¨æ¿
  async generateBusinessDashboard(timeRange: TimeRange): Promise<BusinessDashboard> {
    try {
      console.log('ğŸ“Š ç”Ÿæˆä¸šåŠ¡ä»ªè¡¨æ¿æ•°æ®');
      
      const [
        userMetrics,
        revenueMetrics,
        productMetrics,
        technicalMetrics
      ] = await Promise.all([
        this.calculateUserMetrics(timeRange),
        this.calculateRevenueMetrics(timeRange),
        this.calculateProductMetrics(timeRange),
        this.calculateTechnicalMetrics(timeRange)
      ]);

      return {
        period: timeRange,
        overview: {
          totalUsers: userMetrics.totalUsers,
          activeUsers: userMetrics.activeUsers,
          totalRevenue: revenueMetrics.totalRevenue,
          videosGenerated: productMetrics.videosGenerated,
          systemUptime: technicalMetrics.uptime
        },
        growth: {
          userGrowthRate: userMetrics.growthRate,
          revenueGrowthRate: revenueMetrics.growthRate,
          videoGenerationGrowth: productMetrics.growthRate
        },
        performance: {
          videoSuccessRate: productMetrics.successRate,
          averageProcessingTime: productMetrics.averageProcessingTime,
          apiResponseTime: technicalMetrics.averageResponseTime,
          errorRate: technicalMetrics.errorRate
        },
        generatedAt: new Date()
      };

    } catch (error) {
      console.error('ä¸šåŠ¡ä»ªè¡¨æ¿ç”Ÿæˆå¤±è´¥:', error);
      throw error;
    }
  }

  // ğŸ’° æ”¶å…¥åˆ†æ
  private async calculateRevenueMetrics(timeRange: TimeRange): Promise<RevenueMetrics> {
    const purchases = await db.purchase.findMany({
      where: {
        createdAt: {
          gte: timeRange.start,
          lte: timeRange.end
        },
        status: 'completed'
      },
      include: {
        user: {
          select: { email: true, createdAt: true }
        }
      }
    });

    const totalRevenue = purchases.reduce((sum, p) => sum + p.amount, 0);
    const uniqueUsers = new Set(purchases.map(p => p.userId)).size;
    const arpu = uniqueUsers > 0 ? totalRevenue / uniqueUsers : 0;

    // æŒ‰äº§å“ç±»å‹åˆ†ç»„åˆ†æ
    const packageAnalysis = purchases.reduce((acc, purchase) => {
      const packageType = purchase.packageType;
      if (!acc[packageType]) {
        acc[packageType] = { count: 0, revenue: 0 };
      }
      acc[packageType].count++;
      acc[packageType].revenue += purchase.amount;
      return acc;
    }, {} as Record<string, { count: number; revenue: number }>);

    return {
      totalRevenue,
      transactionCount: purchases.length,
      averageRevenuePerUser: arpu,
      averageTransactionValue: purchases.length > 0 ? totalRevenue / purchases.length : 0,
      packageBreakdown: packageAnalysis,
      growthRate: await this.calculateGrowthRate('revenue', timeRange)
    };
  }

  // ğŸ¬ äº§å“ä½¿ç”¨åˆ†æ
  private async calculateProductMetrics(timeRange: TimeRange): Promise<ProductMetrics> {
    const videos = await db.video.findMany({
      where: {
        createdAt: {
          gte: timeRange.start,
          lte: timeRange.end
        }
      },
      include: {
        user: {
          select: { email: true }
        }
      }
    });

    const completedVideos = videos.filter(v => v.status === 'completed');
    const failedVideos = videos.filter(v => v.status === 'failed');
    const processingVideos = videos.filter(v => v.status === 'processing');

    const successRate = videos.length > 0 ? (completedVideos.length / videos.length) * 100 : 0;

    // è®¡ç®—å¹³å‡å¤„ç†æ—¶é—´
    const completedWithTimes = completedVideos.filter(v => v.completedAt && v.createdAt);
    const averageProcessingTime = completedWithTimes.length > 0 
      ? completedWithTimes.reduce((sum, v) => 
          sum + (v.completedAt!.getTime() - v.createdAt.getTime()), 0
        ) / completedWithTimes.length
      : 0;

    return {
      videosGenerated: videos.length,
      completedVideos: completedVideos.length,
      failedVideos: failedVideos.length,
      processingVideos: processingVideos.length,
      successRate,
      averageProcessingTime: Math.round(averageProcessingTime / 1000), // è½¬æ¢ä¸ºç§’
      uniqueUsers: new Set(videos.map(v => v.userId)).size,
      growthRate: await this.calculateGrowthRate('videos', timeRange)
    };
  }
}
```

### 9.2 å®æ—¶ç›‘æ§ç³»ç»Ÿ

#### ğŸ” é”™è¯¯è¿½è¸ªä¸åˆ†æ

**æ™ºèƒ½é”™è¯¯ç›‘æ§ç³»ç»Ÿ**
```typescript
// é”™è¯¯ç›‘æ§ä¸åˆ†ææœåŠ¡
export class ErrorTrackingService {
  private readonly errorConfig = {
    categories: {
      system: ['database', 'network', 'memory', 'cpu'],
      application: ['authentication', 'payment', 'video_generation', 'api'],
      business: ['insufficient_credits', 'payment_failed', 'generation_timeout'],
      security: ['unauthorized_access', 'suspicious_activity', 'data_breach']
    },
    severity: {
      critical: 1,
      high: 2,
      medium: 3,
      low: 4,
      info: 5
    },
    retention: {
      critical: 90,   // 90å¤©
      high: 60,       // 60å¤©
      medium: 30,     // 30å¤©
      low: 7          // 7å¤©
    }
  };

  // ğŸš¨ é”™è¯¯æ•è·ä¸åˆ†ç±»
  async captureError(error: ApplicationError): Promise<ErrorRecord> {
    try {
      // 1. é”™è¯¯åˆ†ç±»
      const category = this.categorizeError(error);
      const severity = this.determineSeverity(error, category);
      
      // 2. æå–é”™è¯¯ä¸Šä¸‹æ–‡
      const context = await this.extractErrorContext(error);
      
      // 3. ç”Ÿæˆé”™è¯¯æŒ‡çº¹
      const fingerprint = this.generateErrorFingerprint(error);
      
      // 4. æ£€æŸ¥æ˜¯å¦ä¸ºé‡å¤é”™è¯¯
      const isDuplicate = await this.checkDuplicateError(fingerprint);
      
      // 5. è®°å½•é”™è¯¯
      const errorRecord = await db.errorLog.create({
        data: {
          message: error.message,
          stack: error.stack,
          category,
          severity,
          fingerprint,
          context: context,
          isDuplicate,
          occurrences: isDuplicate ? 1 : 1,
          firstOccurrence: new Date(),
          lastOccurrence: new Date()
        }
      });

      // 6. å®æ—¶å‘Šè­¦
      if (severity <= this.errorConfig.severity.high) {
        await this.triggerImmediateAlert(errorRecord);
      }

      // 7. é”™è¯¯ç»Ÿè®¡æ›´æ–°
      await this.updateErrorStatistics(category, severity);

      return errorRecord;

    } catch (trackingError) {
      console.error('é”™è¯¯è¿½è¸ªå¤±è´¥:', trackingError);
      // å¤‡ç”¨é”™è¯¯è®°å½•
      return this.fallbackErrorLogging(error);
    }
  }

  // ğŸ“Š é”™è¯¯åˆ†ææŠ¥å‘Š
  async generateErrorAnalysisReport(timeRange: TimeRange): Promise<ErrorAnalysisReport> {
    const errors = await db.errorLog.findMany({
      where: {
        createdAt: {
          gte: timeRange.start,
          lte: timeRange.end
        }
      }
    });

    // æŒ‰ç±»åˆ«ç»Ÿè®¡
    const categoryStats = errors.reduce((acc, error) => {
      const category = error.category;
      if (!acc[category]) {
        acc[category] = { count: 0, critical: 0, high: 0, medium: 0, low: 0 };
      }
      acc[category].count++;
      
      switch (error.severity) {
        case 1: acc[category].critical++; break;
        case 2: acc[category].high++; break;
        case 3: acc[category].medium++; break;
        case 4: acc[category].low++; break;
      }
      
      return acc;
    }, {} as Record<string, ErrorCategoryStats>);

    // è¶‹åŠ¿åˆ†æ
    const trendAnalysis = await this.analyzeErrorTrends(timeRange);
    
    // çƒ­ç‚¹é—®é¢˜è¯†åˆ«
    const hotspots = await this.identifyErrorHotspots(errors);

    return {
      period: timeRange,
      summary: {
        totalErrors: errors.length,
        uniqueErrors: new Set(errors.map(e => e.fingerprint)).size,
        criticalErrors: errors.filter(e => e.severity === 1).length,
        resolvedErrors: errors.filter(e => e.resolved).length
      },
      categoryBreakdown: categoryStats,
      trends: trendAnalysis,
      hotspots,
      recommendations: await this.generateErrorRecommendations(categoryStats, hotspots),
      generatedAt: new Date()
    };
  }

  // ğŸ”§ è‡ªåŠ¨é”™è¯¯ä¿®å¤
  async attemptAutoRemediation(errorRecord: ErrorRecord): Promise<RemediationResult> {
    try {
      console.log(`ğŸ”§ å°è¯•è‡ªåŠ¨ä¿®å¤é”™è¯¯: ${errorRecord.category}`);
      
      const remediationStrategy = this.selectRemediationStrategy(errorRecord);
      
      if (!remediationStrategy) {
        return {
          success: false,
          reason: 'No suitable remediation strategy found',
          requiresManualIntervention: true
        };
      }

      const result = await this.executeRemediation(remediationStrategy, errorRecord);
      
      if (result.success) {
        // æ ‡è®°é”™è¯¯ä¸ºå·²ä¿®å¤
        await db.errorLog.update({
          where: { id: errorRecord.id },
          data: {
            resolved: true,
            resolvedAt: new Date(),
            remediationApplied: remediationStrategy.name
          }
        });
      }

      return result;

    } catch (error) {
      console.error('è‡ªåŠ¨ä¿®å¤å¤±è´¥:', error);
      return {
        success: false,
        reason: error.message,
        requiresManualIntervention: true
      };
    }
  }
}
```

---

## âš™ï¸ ç¬¬åéƒ¨åˆ†ï¼šDevOpsä¸CI/CDæ¶æ„

### 10.1 æŒç»­é›†æˆæµæ°´çº¿

#### ğŸ”„ è‡ªåŠ¨åŒ–éƒ¨ç½²æµç¨‹

**å®Œæ•´CI/CDæµç¨‹è®¾è®¡**
```typescript
// CI/CDæµæ°´çº¿é…ç½®
export const CICDPipeline = {
  // ğŸŒŠ æµæ°´çº¿é˜¶æ®µ
  stages: {
    'code-quality': {
      name: 'ä»£ç è´¨é‡æ£€æŸ¥',
      jobs: ['lint', 'type-check', 'security-scan'],
      parallel: true,
      timeout: '5 minutes'
    },
    'testing': {
      name: 'è‡ªåŠ¨åŒ–æµ‹è¯•',
      jobs: ['unit-tests', 'integration-tests', 'e2e-tests'],
      dependsOn: ['code-quality'],
      timeout: '15 minutes'
    },
    'build': {
      name: 'æ„å»ºåº”ç”¨',
      jobs: ['build-app', 'optimize-assets'],
      dependsOn: ['testing'],
      timeout: '10 minutes'
    },
    'deploy': {
      name: 'éƒ¨ç½²å‘å¸ƒ',
      jobs: ['deploy-cloudflare', 'deploy-railway', 'health-check'],
      dependsOn: ['build'],
      timeout: '20 minutes'
    }
  },

  // ğŸ¯ è§¦å‘æ¡ä»¶
  triggers: {
    push: {
      branches: ['main', 'develop'],
      paths: ['src/**', 'package.json', 'next.config.js']
    },
    pullRequest: {
      branches: ['main'],
      types: ['opened', 'synchronize', 'reopened']
    },
    schedule: {
      nightly: '0 2 * * *', // æ¯å¤©å‡Œæ™¨2ç‚¹
      weekly: '0 6 * * 0'   // æ¯å‘¨æ—¥æ—©ä¸Š6ç‚¹
    }
  },

  // ğŸ”§ ç¯å¢ƒé…ç½®
  environments: {
    development: {
      autoApproval: true,
      requiresTests: true,
      secrets: ['DEV_DATABASE_URL', 'DEV_VEO3_API_KEY']
    },
    staging: {
      autoApproval: false,
      requiresApproval: ['tech-lead'],
      secrets: ['STAGING_DATABASE_URL', 'STAGING_VEO3_API_KEY']
    },
    production: {
      autoApproval: false,
      requiresApproval: ['tech-lead', 'product-manager'],
      secrets: ['PROD_DATABASE_URL', 'PROD_VEO3_API_KEY']
    }
  }
};

// éƒ¨ç½²è‡ªåŠ¨åŒ–æœåŠ¡
export class DeploymentAutomationService {
  private readonly deploymentConfig = {
    strategies: {
      blueGreen: true,      // è“ç»¿éƒ¨ç½²
      rollingUpdate: false, // æ»šåŠ¨æ›´æ–°
      canary: false         // é‡‘ä¸é›€å‘å¸ƒ
    },
    healthChecks: {
      interval: 30000,      // 30ç§’
      timeout: 5000,        // 5ç§’è¶…æ—¶
      retries: 3,           // 3æ¬¡é‡è¯•
      endpoints: ['/api/health', '/api/check-env']
    },
    rollback: {
      automatic: true,      // è‡ªåŠ¨å›æ»š
      threshold: 10,        // 10%é”™è¯¯ç‡é˜ˆå€¼
      window: 300000        // 5åˆ†é’Ÿè§‚å¯Ÿçª—å£
    }
  };

  // ğŸš€ æ‰§è¡Œéƒ¨ç½²
  async executeDeployment(deploymentRequest: DeploymentRequest): Promise<DeploymentResult> {
    const deploymentId = `deploy_${Date.now()}`;
    
    try {
      console.log(`ğŸš€ å¼€å§‹éƒ¨ç½²: ${deploymentId}`);
      
      // 1. é¢„éƒ¨ç½²éªŒè¯
      await this.preDeploymentValidation(deploymentRequest);
      
      // 2. æ‰§è¡Œè“ç»¿éƒ¨ç½²
      const deployResult = await this.executeBlueGreenDeployment(deploymentRequest);
      
      // 3. å¥åº·æ£€æŸ¥
      await this.performHealthChecks(deployResult.newVersion);
      
      // 4. æµé‡åˆ‡æ¢
      await this.switchTraffic(deployResult.oldVersion, deployResult.newVersion);
      
      // 5. éƒ¨ç½²åéªŒè¯
      await this.postDeploymentValidation(deployResult.newVersion);
      
      // 6. æ¸…ç†æ—§ç‰ˆæœ¬
      await this.cleanupOldVersion(deployResult.oldVersion);

      return {
        success: true,
        deploymentId,
        version: deployResult.newVersion,
        environment: deploymentRequest.environment,
        timestamp: new Date(),
        metrics: {
          deploymentTime: Date.now() - parseInt(deploymentId.split('_')[1]),
          healthChecksPassed: true,
          rollbackTriggered: false
        }
      };

    } catch (error) {
      console.error(`éƒ¨ç½²å¤±è´¥: ${deploymentId}`, error);
      
      // è‡ªåŠ¨å›æ»š
      if (this.deploymentConfig.rollback.automatic) {
        await this.executeRollback(deploymentRequest.environment);
      }
      
      throw error;
    }
  }

  // ğŸ”„ è‡ªåŠ¨å›æ»šæœºåˆ¶
  async executeRollback(environment: string): Promise<RollbackResult> {
    try {
      console.log(`ğŸ”„ æ‰§è¡Œè‡ªåŠ¨å›æ»š: ${environment}`);
      
      // 1. è·å–ä¸Šä¸€ä¸ªç¨³å®šç‰ˆæœ¬
      const previousVersion = await this.getPreviousStableVersion(environment);
      
      // 2. å¿«é€Ÿåˆ‡æ¢åˆ°ä¸Šä¸€ç‰ˆæœ¬
      await this.quickSwitchVersion(environment, previousVersion);
      
      // 3. éªŒè¯å›æ»šç»“æœ
      await this.validateRollback(environment, previousVersion);
      
      // 4. é€šçŸ¥ç›¸å…³äººå‘˜
      await this.notifyRollbackComplete(environment, previousVersion);

      return {
        success: true,
        rolledBackTo: previousVersion,
        rollbackTime: new Date(),
        reason: 'automatic_deployment_failure'
      };

    } catch (rollbackError) {
      console.error('å›æ»šå¤±è´¥:', rollbackError);
      await this.escalateRollbackFailure(environment, rollbackError);
      throw rollbackError;
    }
  }
}
```

### 10.2 åŸºç¡€è®¾æ–½å³ä»£ç 

#### ğŸ—ï¸ é…ç½®ç®¡ç†

**åŸºç¡€è®¾æ–½è‡ªåŠ¨åŒ–é…ç½®**
```typescript
// Terraformé…ç½®ç®¡ç†
export const InfrastructureConfig = {
  // â˜ï¸ Cloudflareèµ„æº
  cloudflare: {
    domain: 'cuttingasmr.org',
    zone: 'cloudflare_zone.main',
    pages: {
      name: 'cuttingasmr-app',
      productionBranch: 'main',
      buildConfig: {
        buildCommand: 'npm run build',
        destinationDir: '.next',
        nodeVersion: '18'
      }
    },
    dns: [
      { name: '@', type: 'A', value: '192.0.2.1' },
      { name: 'www', type: 'CNAME', value: 'cuttingasmr.org' },
      { name: 'backup', type: 'CNAME', value: 'railway.app' }
    ]
  },

  // ğŸš‚ Railwayèµ„æº
  railway: {
    project: 'cuttingasmr-backup',
    service: {
      name: 'web',
      source: 'github:owner/cuttingasmr',
      buildpack: 'nodejs',
      runtime: 'node18'
    },
    database: {
      type: 'postgresql',
      version: '13',
      storage: '1GB'
    }
  },

  // ğŸ”§ ç¯å¢ƒå˜é‡ç®¡ç†
  secrets: {
    production: [
      'DATABASE_URL',
      'CLERK_SECRET_KEY',
      'VEO3_API_KEY',
      'CREEM_API_KEY',
      'CREEM_WEBHOOK_SECRET'
    ],
    staging: [
      'STAGING_DATABASE_URL',
      'STAGING_CLERK_SECRET_KEY',
      'STAGING_VEO3_API_KEY'
    ]
  }
};

// é…ç½®ç®¡ç†æœåŠ¡
export class ConfigurationManagementService {
  private readonly configSources = {
    environment: process.env,
    vault: 'hashicorp-vault',     // æ•æ„Ÿä¿¡æ¯
    consul: 'consul-kv',          // é…ç½®ä¿¡æ¯
    kubernetes: 'k8s-configmap'  // å®¹å™¨é…ç½®
  };

  // ğŸ”§ åŠ¨æ€é…ç½®åŠ è½½
  async loadConfiguration(environment: string): Promise<ApplicationConfig> {
    try {
      console.log(`ğŸ”§ åŠ è½½ ${environment} ç¯å¢ƒé…ç½®`);
      
      // 1. åŸºç¡€é…ç½®
      const baseConfig = await this.loadBaseConfiguration();
      
      // 2. ç¯å¢ƒç‰¹å®šé…ç½®
      const envConfig = await this.loadEnvironmentConfiguration(environment);
      
      // 3. æ•æ„Ÿä¿¡æ¯é…ç½®
      const secretsConfig = await this.loadSecretsConfiguration(environment);
      
      // 4. åˆå¹¶é…ç½®
      const mergedConfig = this.mergeConfigurations(baseConfig, envConfig, secretsConfig);
      
      // 5. éªŒè¯é…ç½®
      await this.validateConfiguration(mergedConfig);
      
      return mergedConfig;

    } catch (error) {
      console.error('é…ç½®åŠ è½½å¤±è´¥:', error);
      throw new Error(`Configuration loading failed: ${error.message}`);
    }
  }

  // âœ… é…ç½®éªŒè¯
  private async validateConfiguration(config: ApplicationConfig): Promise<void> {
    const requiredKeys = [
      'DATABASE_URL',
      'CLERK_SECRET_KEY',
      'VEO3_API_KEY',
      'NEXT_PUBLIC_APP_URL'
    ];

    const missingKeys = requiredKeys.filter(key => !config[key]);
    
    if (missingKeys.length > 0) {
      throw new Error(`Missing required configuration keys: ${missingKeys.join(', ')}`);
    }

    // éªŒè¯æ•°æ®åº“è¿æ¥
    await this.validateDatabaseConnection(config.DATABASE_URL);
    
    // éªŒè¯APIå¯†é’¥
    await this.validateAPIKeys(config);
    
    console.log('âœ… é…ç½®éªŒè¯é€šè¿‡');
  }

  // ğŸ”„ é…ç½®çƒ­æ›´æ–°
  async updateConfiguration(key: string, value: string, environment: string): Promise<void> {
    try {
      console.log(`ğŸ”„ æ›´æ–°é…ç½®: ${key} in ${environment}`);
      
      // 1. éªŒè¯æ–°é…ç½®å€¼
      await this.validateConfigurationValue(key, value);
      
      // 2. å¤‡ä»½å½“å‰é…ç½®
      await this.backupCurrentConfiguration(environment);
      
      // 3. æ›´æ–°é…ç½®
      await this.updateConfigurationValue(key, value, environment);
      
      // 4. é€šçŸ¥åº”ç”¨é‡æ–°åŠ è½½
      await this.notifyConfigurationChange(key, environment);
      
      // 5. éªŒè¯æ›´æ–°ç»“æœ
      await this.validateConfigurationUpdate(key, value, environment);
      
      console.log(`âœ… é…ç½®æ›´æ–°æˆåŠŸ: ${key}`);

    } catch (error) {
      console.error('é…ç½®æ›´æ–°å¤±è´¥:', error);
      await this.rollbackConfiguration(environment);
      throw error;
    }
  }
}
```

---

## ğŸš€ ç¬¬åä¸€éƒ¨åˆ†ï¼šæ‰©å±•æ€§ä¸æœªæ¥è§„åˆ’

### 11.1 æŠ€æœ¯æ¶æ„æ¼”è¿›

#### ğŸ“ˆ æ‰©å±•æ€§è®¾è®¡åŸåˆ™

**å¯æ‰©å±•æ¶æ„è®¾è®¡**
```typescript
// æ‰©å±•æ€§æ¶æ„è§„åˆ’
export const ScalabilityArchitecture = {
  // ğŸ¯ æ‰©å±•ç»´åº¦
  scalingDimensions: {
    horizontal: {
      userTraffic: 'CDN + è´Ÿè½½å‡è¡¡',
      apiRequests: 'APIç½‘å…³ + æœåŠ¡ç½‘æ ¼',
      database: 'è¯»å†™åˆ†ç¦» + åˆ†ç‰‡',
      storage: 'åˆ†å¸ƒå¼å­˜å‚¨'
    },
    vertical: {
      compute: 'Serverless Functionsè‡ªåŠ¨æ‰©å±•',
      memory: 'æ™ºèƒ½ç¼“å­˜ç­–ç•¥',
      bandwidth: 'CDNå…¨çƒåˆ†å‘'
    }
  },

  // ğŸ“Š æ€§èƒ½ç›®æ ‡
  performanceTargets: {
    '2024 Q4': {
      users: 10000,
      videosPerDay: 1000,
      responseTime: '<2s',
      uptime: '99.9%'
    },
    '2025 Q2': {
      users: 50000,
      videosPerDay: 5000,
      responseTime: '<1.5s',
      uptime: '99.95%'
    },
    '2025 Q4': {
      users: 100000,
      videosPerDay: 15000,
      responseTime: '<1s',
      uptime: '99.99%'
    }
  },

  // ğŸ”§ æŠ€æœ¯æ¼”è¿›è·¯çº¿
  evolutionRoadmap: {
    phase1: {
      name: 'å•ä½“ä¼˜åŒ–',
      timeline: '2024 Q1-Q2',
      improvements: ['ä»£ç ä¼˜åŒ–', 'ç¼“å­˜ç­–ç•¥', 'CDNéƒ¨ç½²']
    },
    phase2: {
      name: 'æœåŠ¡æ‹†åˆ†',
      timeline: '2024 Q3-Q4',
      improvements: ['å¾®æœåŠ¡æ¶æ„', 'æ¶ˆæ¯é˜Ÿåˆ—', 'æœåŠ¡å‘ç°']
    },
    phase3: {
      name: 'æ™ºèƒ½åŒ–å‡çº§',
      timeline: '2025 Q1-Q2',
      improvements: ['AIæ¨èç³»ç»Ÿ', 'æ™ºèƒ½ç¼“å­˜', 'è‡ªåŠ¨åŒ–è¿ç»´']
    },
    phase4: {
      name: 'å…¨çƒåŒ–éƒ¨ç½²',
      timeline: '2025 Q3-Q4',
      improvements: ['å¤šåŒºåŸŸéƒ¨ç½²', 'æ•°æ®æœ¬åœ°åŒ–', 'å…¨çƒCDN']
    }
  }
};

// å®¹é‡è§„åˆ’æœåŠ¡
export class CapacityPlanningService {
  private readonly planningConfig = {
    // ğŸ“Š å…³é”®æŒ‡æ ‡é˜ˆå€¼
    thresholds: {
      cpu: 70,              // CPUä½¿ç”¨ç‡70%è§¦å‘æ‰©å®¹
      memory: 80,           // å†…å­˜ä½¿ç”¨ç‡80%è§¦å‘æ‰©å®¹
      database: 75,         // æ•°æ®åº“è¿æ¥75%è§¦å‘ä¼˜åŒ–
      storage: 85,          // å­˜å‚¨ä½¿ç”¨85%è§¦å‘æ‰©å®¹
      responseTime: 2000    // å“åº”æ—¶é—´è¶…è¿‡2ç§’è§¦å‘ä¼˜åŒ–
    },
    
    // ğŸ“ˆ å¢é•¿é¢„æµ‹æ¨¡å‹
    growthModels: {
      exponential: { factor: 1.5, period: 'quarterly' },
      linear: { rate: 100, period: 'monthly' },
      seasonal: { peak: 2.0, base: 1.0, periods: ['holiday', 'weekend'] }
    }
  };

  // ğŸ“Š å®¹é‡éœ€æ±‚é¢„æµ‹
  async forecastCapacityRequirements(timeHorizon: number): Promise<CapacityForecast> {
    try {
      console.log(`ğŸ“Š é¢„æµ‹æœªæ¥ ${timeHorizon} ä¸ªæœˆçš„å®¹é‡éœ€æ±‚`);
      
      // 1. æ”¶é›†å†å²æ•°æ®
      const historicalData = await this.collectHistoricalMetrics(timeHorizon);
      
      // 2. åˆ†æå¢é•¿è¶‹åŠ¿
      const growthTrends = await this.analyzeGrowthTrends(historicalData);
      
      // 3. åº”ç”¨é¢„æµ‹æ¨¡å‹
      const forecast = await this.applyPredictionModels(growthTrends, timeHorizon);
      
      // 4. è€ƒè™‘å­£èŠ‚æ€§å› ç´ 
      const adjustedForecast = await this.adjustForSeasonality(forecast);
      
      // 5. ç”Ÿæˆæ‰©å®¹å»ºè®®
      const recommendations = await this.generateScalingRecommendations(adjustedForecast);

      return {
        forecastPeriod: timeHorizon,
        predictions: {
          userGrowth: adjustedForecast.users,
          trafficGrowth: adjustedForecast.traffic,
          storageGrowth: adjustedForecast.storage,
          computeRequirements: adjustedForecast.compute
        },
        recommendations,
        confidence: this.calculateConfidenceLevel(historicalData),
        generatedAt: new Date()
      };

    } catch (error) {
      console.error('å®¹é‡é¢„æµ‹å¤±è´¥:', error);
      throw error;
    }
  }

  // ğŸ¯ è‡ªåŠ¨æ‰©å®¹å†³ç­–
  async makeScalingDecision(currentMetrics: SystemMetrics): Promise<ScalingDecision> {
    try {
      console.log('ğŸ¯ è¯„ä¼°æ‰©å®¹éœ€æ±‚');
      
      // 1. è¯„ä¼°å½“å‰è´Ÿè½½
      const loadAssessment = await this.assessCurrentLoad(currentMetrics);
      
      // 2. é¢„æµ‹çŸ­æœŸè¶‹åŠ¿
      const shortTermTrend = await this.predictShortTermTrend(currentMetrics);
      
      // 3. è®¡ç®—æ‰©å®¹éœ€æ±‚
      const scalingNeed = await this.calculateScalingNeed(loadAssessment, shortTermTrend);
      
      // 4. è¯„ä¼°æˆæœ¬æ•ˆç›Š
      const costBenefit = await this.evaluateCostBenefit(scalingNeed);
      
      // 5. ç”Ÿæˆæ‰©å®¹å†³ç­–
      const decision = this.generateScalingDecision(scalingNeed, costBenefit);

      return {
        action: decision.action,
        reason: decision.reason,
        timeline: decision.timeline,
        expectedImpact: decision.impact,
        costEstimate: decision.cost,
        confidence: decision.confidence,
        timestamp: new Date()
      };

    } catch (error) {
      console.error('æ‰©å®¹å†³ç­–å¤±è´¥:', error);
      throw error;
    }
  }
}
```

### 11.2 æ–°åŠŸèƒ½è§„åˆ’

#### ğŸ¨ äº§å“åŠŸèƒ½è·¯çº¿å›¾

**åŠŸèƒ½è¿­ä»£è§„åˆ’**
```typescript
// äº§å“åŠŸèƒ½è·¯çº¿å›¾
export const ProductRoadmap = {
  // ğŸ¯ è¿‘æœŸåŠŸèƒ½ (3ä¸ªæœˆ)
  nearTerm: {
    videoEnhancements: {
      title: 'è§†é¢‘ç”Ÿæˆå¢å¼º',
      features: [
        'å¤šç§è§†é¢‘é£æ ¼é€‰æ‹©',
        'è‡ªå®šä¹‰è§†é¢‘é•¿åº¦ (5-30ç§’)',
        'é«˜æ¸…1080pæ”¯æŒ',
        'è§†é¢‘é¢„è§ˆåŠŸèƒ½'
      ],
      priority: 'high',
      estimatedEffort: '6å‘¨',
      dependencies: ['Veo3 APIå‡çº§']
    },
    
    userExperience: {
      title: 'ç”¨æˆ·ä½“éªŒä¼˜åŒ–',
      features: [
        'ç§»åŠ¨ç«¯é€‚é…ä¼˜åŒ–',
        'è§†é¢‘ç”Ÿæˆè¿›åº¦æ˜¾ç¤º',
        'æ‰¹é‡è§†é¢‘ç”Ÿæˆ',
        'ä¸ªäººè§†é¢‘æ”¶è—å¤¹'
      ],
      priority: 'high',
      estimatedEffort: '4å‘¨',
      dependencies: ['UI/UXé‡è®¾è®¡']
    },
    
    paymentSystem: {
      title: 'æ”¯ä»˜ç³»ç»Ÿæ‰©å±•',
      features: [
        'æ”¯ä»˜å®/å¾®ä¿¡æ”¯ä»˜',
        'è®¢é˜…æ¨¡å¼',
        'ä¼ä¸šè´¦æˆ·æ”¯æŒ',
        'å‘ç¥¨ç³»ç»Ÿ'
      ],
      priority: 'medium',
      estimatedEffort: '8å‘¨',
      dependencies: ['åˆè§„å®¡æ ¸']
    }
  },

  // ğŸš€ ä¸­æœŸåŠŸèƒ½ (6ä¸ªæœˆ)
  midTerm: {
    aiCapabilities: {
      title: 'AIèƒ½åŠ›æ‰©å±•',
      features: [
        'æ™ºèƒ½æç¤ºè¯å»ºè®®',
        'é£æ ¼è¿ç§»åŠŸèƒ½',
        'éŸ³é¢‘å¢å¼ºå¤„ç†',
        'è‡ªåŠ¨å­—å¹•ç”Ÿæˆ'
      ],
      priority: 'high',
      estimatedEffort: '12å‘¨',
      dependencies: ['AIæ¨¡å‹è®­ç»ƒ', 'éŸ³é¢‘å¤„ç†API']
    },
    
    socialFeatures: {
      title: 'ç¤¾äº¤åŠŸèƒ½',
      features: [
        'è§†é¢‘åˆ†äº«åŠŸèƒ½',
        'ç”¨æˆ·è¯„è®ºç³»ç»Ÿ',
        'åˆ›ä½œè€…æ’è¡Œæ¦œ',
        'ç¤¾åŒºæŒ‘æˆ˜æ´»åŠ¨'
      ],
      priority: 'medium',
      estimatedEffort: '10å‘¨',
      dependencies: ['å†…å®¹å®¡æ ¸ç³»ç»Ÿ']
    },
    
    analytics: {
      title: 'æ•°æ®åˆ†æå¹³å°',
      features: [
        'ç”¨æˆ·è¡Œä¸ºåˆ†æ',
        'åˆ›ä½œæ•ˆæœç»Ÿè®¡',
        'æ”¶å…¥åˆ†ææŠ¥å‘Š',
        'A/Bæµ‹è¯•æ¡†æ¶'
      ],
      priority: 'medium',
      estimatedEffort: '8å‘¨',
      dependencies: ['æ•°æ®ä»“åº“å»ºè®¾']
    }
  },

  // ğŸŒŸ é•¿æœŸæ„¿æ™¯ (12ä¸ªæœˆ)
  longTerm: {
    platformExpansion: {
      title: 'å¹³å°ç”Ÿæ€æ‰©å±•',
      features: [
        'APIå¼€æ”¾å¹³å°',
        'ç¬¬ä¸‰æ–¹å¼€å‘è€…å·¥å…·',
        'æ’ä»¶å¸‚åœº',
        'ä¼ä¸šçº§è§£å†³æ–¹æ¡ˆ'
      ],
      priority: 'strategic',
      estimatedEffort: '20å‘¨',
      dependencies: ['æ¶æ„é‡æ„', 'å®‰å…¨åŠ å›º']
    },
    
    globalExpansion: {
      title: 'å…¨çƒåŒ–æ‰©å±•',
      features: [
        'å¤šè¯­è¨€æ”¯æŒ',
        'æœ¬åœ°åŒ–æ”¯ä»˜',
        'åŒºåŸŸåŒ–å†…å®¹',
        'åˆè§„æ€§é€‚é…'
      ],
      priority: 'strategic',
      estimatedEffort: '16å‘¨',
      dependencies: ['æ³•å¾‹åˆè§„', 'æœ¬åœ°åŒ–å›¢é˜Ÿ']
    },
    
    aiInnovation: {
      title: 'AIåˆ›æ–°åŠŸèƒ½',
      features: [
        'å®æ—¶è§†é¢‘ç”Ÿæˆ',
        '3Dè§†é¢‘æ”¯æŒ',
        'VR/ARé›†æˆ',
        'ä¸ªæ€§åŒ–AIåŠ©æ‰‹'
      ],
      priority: 'innovation',
      estimatedEffort: '24å‘¨',
      dependencies: ['å‰æ²¿AIæŠ€æœ¯', 'ç¡¬ä»¶å‡çº§']
    }
  }
};

// åŠŸèƒ½å¼€å‘ç®¡ç†æœåŠ¡
export class FeatureDevelopmentService {
  private readonly developmentConfig = {
    // ğŸ¯ å¼€å‘æµç¨‹
    developmentProcess: {
      planning: { duration: 2, activities: ['éœ€æ±‚åˆ†æ', 'æŠ€æœ¯è®¾è®¡', 'èµ„æºè§„åˆ’'] },
      development: { duration: 6, activities: ['ç¼–ç å®ç°', 'å•å…ƒæµ‹è¯•', 'é›†æˆæµ‹è¯•'] },
      testing: { duration: 2, activities: ['åŠŸèƒ½æµ‹è¯•', 'æ€§èƒ½æµ‹è¯•', 'å®‰å…¨æµ‹è¯•'] },
      deployment: { duration: 1, activities: ['éƒ¨ç½²å‘å¸ƒ', 'ç›‘æ§è§‚å¯Ÿ', 'ç”¨æˆ·åé¦ˆ'] }
    },
    
    // ğŸ“Š æˆåŠŸæŒ‡æ ‡
    successMetrics: {
      technical: ['ä»£ç è¦†ç›–ç‡ >80%', 'æ€§èƒ½æå‡ >20%', 'é”™è¯¯ç‡ <1%'],
      business: ['ç”¨æˆ·é‡‡ç”¨ç‡ >70%', 'ç”¨æˆ·æ»¡æ„åº¦ >4.5', 'NPS >50'],
      product: ['åŠŸèƒ½å®Œæˆåº¦ 100%', 'éœ€æ±‚è¦†ç›–ç‡ >95%', 'ç”¨æˆ·ä½“éªŒè¯„åˆ† >4.0']
    }
  };

  // ğŸ¯ åŠŸèƒ½ä¼˜å…ˆçº§è¯„ä¼°
  async evaluateFeaturePriority(feature: FeatureProposal): Promise<PriorityScore> {
    try {
      console.log(`ğŸ¯ è¯„ä¼°åŠŸèƒ½ä¼˜å…ˆçº§: ${feature.name}`);
      
      // 1. ä¸šåŠ¡ä»·å€¼è¯„ä¼°
      const businessValue = await this.assessBusinessValue(feature);
      
      // 2. æŠ€æœ¯å¯è¡Œæ€§è¯„ä¼°
      const technicalFeasibility = await this.assessTechnicalFeasibility(feature);
      
      // 3. ç”¨æˆ·éœ€æ±‚å¼ºåº¦è¯„ä¼°
      const userDemand = await this.assessUserDemand(feature);
      
      // 4. ç«äº‰ä¼˜åŠ¿è¯„ä¼°
      const competitiveAdvantage = await this.assessCompetitiveAdvantage(feature);
      
      // 5. ç»¼åˆè¯„åˆ†è®¡ç®—
      const priorityScore = this.calculatePriorityScore({
        businessValue,
        technicalFeasibility,
        userDemand,
        competitiveAdvantage
      });

      return {
        feature: feature.name,
        overallScore: priorityScore.overall,
        breakdown: {
          businessValue: businessValue.score,
          technicalFeasibility: technicalFeasibility.score,
          userDemand: userDemand.score,
          competitiveAdvantage: competitiveAdvantage.score
        },
        recommendation: this.generateRecommendation(priorityScore),
        assessedAt: new Date()
      };

    } catch (error) {
      console.error('åŠŸèƒ½ä¼˜å…ˆçº§è¯„ä¼°å¤±è´¥:', error);
      throw error;
    }
  }
}
```

---

## ğŸ“š ç¬¬åäºŒéƒ¨åˆ†ï¼šæ–‡æ¡£ä¸è§„èŒƒ

### 12.1 å¼€å‘è§„èŒƒ

#### ğŸ“ ä»£ç æ ‡å‡†ä¸è§„èŒƒ

**ä»£ç è´¨é‡æ ‡å‡†**
```typescript
// ä»£ç è§„èŒƒé…ç½®
export const CodingStandards = {
  // ğŸ¨ ä»£ç é£æ ¼
  styling: {
    formatter: 'Prettier',
    linter: 'ESLint',
    rules: {
      indentation: '2 spaces',
      lineLength: 100,
      trailingComma: 'es5',
      semicolons: true,
      quotes: 'single'
    }
  },

  // ğŸ“ æ–‡ä»¶ç»„ç»‡
  fileOrganization: {
    structure: {
      components: 'src/components/',
      hooks: 'src/hooks/',
      utils: 'src/lib/',
      types: 'src/types/',
      tests: '__tests__/'
    },
    naming: {
      components: 'PascalCase',
      files: 'kebab-case',
      variables: 'camelCase',
      constants: 'UPPER_SNAKE_CASE'
    }
  },

  // ğŸ·ï¸ ç±»å‹å®šä¹‰æ ‡å‡†
  typeDefinitions: {
    interfaces: 'PascalCase with I prefix',
    types: 'PascalCase with Type suffix',
    enums: 'PascalCase with singular nouns',
    generics: 'Single uppercase letter'
  },

  // ğŸ“„ æ–‡æ¡£è¦æ±‚
  documentation: {
    functions: 'JSDoc required for public functions',
    components: 'Props documentation required',
    apis: 'OpenAPI specification required',
    readme: 'Updated for each feature'
  }
};

// ä»£ç å®¡æŸ¥æ¸…å•
export const CodeReviewChecklist = {
  // âœ… åŠŸèƒ½æ€§æ£€æŸ¥
  functionality: [
    'åŠŸèƒ½æ˜¯å¦æŒ‰éœ€æ±‚æ­£ç¡®å®ç°',
    'è¾¹ç•Œæ¡ä»¶æ˜¯å¦æ­£ç¡®å¤„ç†',
    'é”™è¯¯å¤„ç†æ˜¯å¦å®Œå–„',
    'æ€§èƒ½æ˜¯å¦æ»¡è¶³è¦æ±‚'
  ],

  // ğŸ›¡ï¸ å®‰å…¨æ€§æ£€æŸ¥
  security: [
    'è¾“å…¥éªŒè¯æ˜¯å¦å……åˆ†',
    'æƒé™æ§åˆ¶æ˜¯å¦æ­£ç¡®',
    'æ•æ„Ÿä¿¡æ¯æ˜¯å¦æ³„éœ²',
    'SQLæ³¨å…¥é˜²æŠ¤æ˜¯å¦åˆ°ä½'
  ],

  // ğŸ¯ å¯ç»´æŠ¤æ€§æ£€æŸ¥
  maintainability: [
    'ä»£ç æ˜¯å¦æ˜“äºç†è§£',
    'å‡½æ•°æ˜¯å¦èŒè´£å•ä¸€',
    'é‡å¤ä»£ç æ˜¯å¦æ¶ˆé™¤',
    'æ³¨é‡Šæ˜¯å¦æ¸…æ™°æœ‰ç”¨'
  ],

  // ğŸ§ª æµ‹è¯•è¦†ç›–
  testing: [
    'å•å…ƒæµ‹è¯•æ˜¯å¦å……åˆ†',
    'é›†æˆæµ‹è¯•æ˜¯å¦è¦†ç›–',
    'æµ‹è¯•ç”¨ä¾‹æ˜¯å¦æœ‰æ„ä¹‰',
    'æµ‹è¯•æ˜¯å¦å¯é‡å¤æ‰§è¡Œ'
  ]
};
```

### 12.2 APIæ–‡æ¡£

#### ğŸ”Œ æ¥å£è§„èŒƒæ–‡æ¡£

**RESTful APIè®¾è®¡è§„èŒƒ**
```yaml
# OpenAPI 3.0 è§„èŒƒ
openapi: 3.0.0
info:
  title: CuttingASMR API
  description: AIé©±åŠ¨çš„ASMRè§†é¢‘ç”Ÿæˆå¹³å°API
  version: 1.0.0
  contact:
    name: API Support
    email: api@cuttingasmr.org
    url: https://cuttingasmr.org/docs

servers:
  - url: https://cuttingasmr.org/api
    description: ç”Ÿäº§ç¯å¢ƒ
  - url: https://staging.cuttingasmr.org/api
    description: æµ‹è¯•ç¯å¢ƒ

paths:
  /generate-video:
    post:
      summary: ç”ŸæˆASMRè§†é¢‘
      description: ä½¿ç”¨AIæŠ€æœ¯æ ¹æ®æç¤ºè¯ç”ŸæˆASMRè§†é¢‘
      tags:
        - Video Generation
      security:
        - BearerAuth: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/VideoGenerationRequest'
            example:
              prompt: "ä¸€ä¸ªå®‰é™çš„æ£®æ—åœºæ™¯ï¼Œé¸Ÿå„¿åœ¨è½»æŸ”åœ°æ­Œå”±"
              aspectRatio: "16:9"
              duration: "8"
      responses:
        '200':
          description: è§†é¢‘ç”Ÿæˆä»»åŠ¡åˆ›å»ºæˆåŠŸ
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/VideoGenerationResponse'
        '400':
          description: è¯·æ±‚å‚æ•°é”™è¯¯
        '401':
          description: æœªæˆæƒè®¿é—®
        '402':
          description: ç§¯åˆ†ä¸è¶³
        '429':
          description: è¯·æ±‚é¢‘ç‡è¿‡é«˜
        '500':
          description: æœåŠ¡å™¨å†…éƒ¨é”™è¯¯

  /credits:
    get:
      summary: æŸ¥è¯¢ç”¨æˆ·ç§¯åˆ†
      description: è·å–å½“å‰ç”¨æˆ·çš„ç§¯åˆ†ä½™é¢å’Œä½¿ç”¨æƒ…å†µ
      tags:
        - Credits
      security:
        - BearerAuth: []
      responses:
        '200':
          description: ç§¯åˆ†ä¿¡æ¯æŸ¥è¯¢æˆåŠŸ
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/CreditsResponse'

components:
  schemas:
    VideoGenerationRequest:
      type: object
      required:
        - prompt
      properties:
        prompt:
          type: string
          description: è§†é¢‘ç”Ÿæˆæç¤ºè¯
          maxLength: 1000
          example: "ä¸€ä¸ªå®‰é™çš„æ£®æ—åœºæ™¯ï¼Œé¸Ÿå„¿åœ¨è½»æŸ”åœ°æ­Œå”±"
        aspectRatio:
          type: string
          enum: ["16:9", "9:16", "1:1"]
          default: "16:9"
          description: è§†é¢‘å®½é«˜æ¯”
        duration:
          type: string
          enum: ["5", "8", "10"]
          default: "8"
          description: è§†é¢‘æ—¶é•¿ï¼ˆç§’ï¼‰

    VideoGenerationResponse:
      type: object
      properties:
        success:
          type: boolean
          description: è¯·æ±‚æ˜¯å¦æˆåŠŸ
        taskId:
          type: string
          description: ä»»åŠ¡IDï¼Œç”¨äºæŸ¥è¯¢ç”ŸæˆçŠ¶æ€
        estimatedTime:
          type: integer
          description: é¢„è®¡å®Œæˆæ—¶é—´ï¼ˆç§’ï¼‰
        creditsUsed:
          type: integer
          description: æ¶ˆè€—çš„ç§¯åˆ†æ•°é‡

    CreditsResponse:
      type: object
      properties:
        totalCredits:
          type: integer
          description: æ€»ç§¯åˆ†æ•°
        usedCredits:
          type: integer
          description: å·²ä½¿ç”¨ç§¯åˆ†æ•°
        availableCredits:
          type: integer
          description: å¯ç”¨ç§¯åˆ†æ•°

  securitySchemes:
    BearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT
```

### 12.3 è¿ç»´æ‰‹å†Œ

#### ğŸ“– è¿ç»´æ“ä½œæŒ‡å—

**ç³»ç»Ÿè¿ç»´æ ‡å‡†æ“ä½œç¨‹åº**
```markdown
# CuttingASMR è¿ç»´æ“ä½œæ‰‹å†Œ

## ğŸš¨ åº”æ€¥å“åº”æµç¨‹

### ç³»ç»Ÿæ•…éšœå¤„ç†

#### 1. æ•…éšœç­‰çº§åˆ†ç±»
- **P0 - ç´§æ€¥**ï¼šç³»ç»Ÿå®Œå…¨ä¸å¯ç”¨ï¼Œå½±å“æ‰€æœ‰ç”¨æˆ·
- **P1 - é«˜**ï¼šæ ¸å¿ƒåŠŸèƒ½å¼‚å¸¸ï¼Œå½±å“å¤§éƒ¨åˆ†ç”¨æˆ·
- **P2 - ä¸­**ï¼šéƒ¨åˆ†åŠŸèƒ½å¼‚å¸¸ï¼Œå½±å“å°‘æ•°ç”¨æˆ·
- **P3 - ä½**ï¼šéå…³é”®åŠŸèƒ½å¼‚å¸¸ï¼Œå½±å“æå°‘ç”¨æˆ·

#### 2. æ•…éšœå“åº”æ—¶é—´
- P0æ•…éšœï¼š15åˆ†é’Ÿå†…å“åº”ï¼Œ1å°æ—¶å†…è§£å†³
- P1æ•…éšœï¼š30åˆ†é’Ÿå†…å“åº”ï¼Œ4å°æ—¶å†…è§£å†³
- P2æ•…éšœï¼š2å°æ—¶å†…å“åº”ï¼Œ24å°æ—¶å†…è§£å†³
- P3æ•…éšœï¼š24å°æ—¶å†…å“åº”ï¼Œ72å°æ—¶å†…è§£å†³

#### 3. æ•…éšœå¤„ç†æ­¥éª¤
1. **æ•…éšœç¡®è®¤**
   - æ£€æŸ¥ç›‘æ§å‘Šè­¦
   - éªŒè¯æ•…éšœå½±å“èŒƒå›´
   - ç¡®å®šæ•…éšœç­‰çº§

2. **ç´§æ€¥å¤„ç†**
   - å¯åŠ¨åº”æ€¥é¢„æ¡ˆ
   - é€šçŸ¥ç›¸å…³äººå‘˜
   - å®æ–½ä¸´æ—¶è§£å†³æ–¹æ¡ˆ

3. **æ ¹å› åˆ†æ**
   - æ”¶é›†æ•…éšœæ—¥å¿—
   - åˆ†ææ•…éšœåŸå› 
   - ç¡®å®šæ°¸ä¹…è§£å†³æ–¹æ¡ˆ

4. **æ•…éšœæ¢å¤**
   - å®æ–½ä¿®å¤æªæ–½
   - éªŒè¯ç³»ç»ŸåŠŸèƒ½
   - æ›´æ–°ç›¸å…³æ–‡æ¡£

5. **äº‹åæ€»ç»“**
   - ç¼–å†™æ•…éšœæŠ¥å‘Š
   - ä¼˜åŒ–ç›‘æ§ç­–ç•¥
   - æ”¹è¿›åº”æ€¥æµç¨‹

## ğŸ”§ æ—¥å¸¸è¿ç»´ä»»åŠ¡

### ç³»ç»Ÿå¥åº·æ£€æŸ¥

#### æ¯æ—¥æ£€æŸ¥é¡¹ç›®
- [ ] ç³»ç»Ÿå¯ç”¨æ€§æ£€æŸ¥
- [ ] å…³é”®æŒ‡æ ‡ç›‘æ§
- [ ] é”™è¯¯æ—¥å¿—å®¡æŸ¥
- [ ] å¤‡ä»½çŠ¶æ€ç¡®è®¤
- [ ] å®‰å…¨å¨èƒæ‰«æ

#### æ¯å‘¨æ£€æŸ¥é¡¹ç›®
- [ ] æ€§èƒ½è¶‹åŠ¿åˆ†æ
- [ ] å®¹é‡ä½¿ç”¨è¯„ä¼°
- [ ] å®‰å…¨è¡¥ä¸æ›´æ–°
- [ ] æ•°æ®åº“ç»´æŠ¤
- [ ] é…ç½®å®¡è®¡

#### æ¯æœˆæ£€æŸ¥é¡¹ç›®
- [ ] å…¨é¢æ€§èƒ½è¯„ä¼°
- [ ] å®‰å…¨å®¡è®¡æŠ¥å‘Š
- [ ] å®¹é‡è§„åˆ’æ›´æ–°
- [ ] ç¾éš¾æ¢å¤æ¼”ç»ƒ
- [ ] æŠ€æœ¯å€ºåŠ¡è¯„ä¼°

### ç»´æŠ¤æ“ä½œæŒ‡å—

#### æ•°æ®åº“ç»´æŠ¤
```bash
# æ•°æ®åº“å¤‡ä»½
pg_dump $DATABASE_URL > backup_$(date +%Y%m%d_%H%M%S).sql

# æ•°æ®åº“ä¼˜åŒ–
psql $DATABASE_URL -c "VACUUM ANALYZE;"

# ç´¢å¼•é‡å»º
psql $DATABASE_URL -c "REINDEX DATABASE cuttingasmr;"
```

#### æ—¥å¿—ç®¡ç†
```bash
# æ—¥å¿—è½®è½¬
logrotate /etc/logrotate.d/cuttingasmr

# æ—¥å¿—æ¸…ç†ï¼ˆä¿ç•™30å¤©ï¼‰
find /var/log/cuttingasmr -name "*.log" -mtime +30 -delete

# æ—¥å¿—åˆ†æ
tail -f /var/log/cuttingasmr/app.log | grep ERROR
```

#### ç¼“å­˜ç®¡ç†
```bash
# æ¸…ç†è¿‡æœŸç¼“å­˜
redis-cli FLUSHDB

# ç¼“å­˜ç»Ÿè®¡
redis-cli INFO memory

# é¢„çƒ­å…³é”®ç¼“å­˜
curl -X POST /api/admin/cache/warmup
```

## ğŸ“Š ç›‘æ§å’Œå‘Šè­¦

### å…³é”®ç›‘æ§æŒ‡æ ‡
- **å¯ç”¨æ€§æŒ‡æ ‡**ï¼šç³»ç»Ÿæ­£å¸¸è¿è¡Œæ—¶é—´ >99.9%
- **æ€§èƒ½æŒ‡æ ‡**ï¼šå¹³å‡å“åº”æ—¶é—´ <2ç§’
- **é”™è¯¯æŒ‡æ ‡**ï¼šé”™è¯¯ç‡ <1%
- **å®¹é‡æŒ‡æ ‡**ï¼šCPUä½¿ç”¨ç‡ <70%ï¼Œå†…å­˜ä½¿ç”¨ç‡ <80%

### å‘Šè­¦é…ç½®
- **å³æ—¶å‘Šè­¦**ï¼šç³»ç»Ÿä¸å¯ç”¨ã€å®‰å…¨å¨èƒ
- **å»¶è¿Ÿå‘Šè­¦**ï¼šæ€§èƒ½ä¸‹é™ã€èµ„æºä¸è¶³
- **æ±‡æ€»å‘Šè­¦**ï¼šæ¯æ—¥/æ¯å‘¨è¿è¡ŒæŠ¥å‘Š

## ğŸ”„ å˜æ›´ç®¡ç†

### å˜æ›´åˆ†ç±»
- **ç´§æ€¥å˜æ›´**ï¼šå®‰å…¨è¡¥ä¸ã€ç´§æ€¥ä¿®å¤
- **æ ‡å‡†å˜æ›´**ï¼šåŠŸèƒ½å‘å¸ƒã€é…ç½®æ›´æ–°
- **æ­£å¸¸å˜æ›´**ï¼šå®šæœŸç»´æŠ¤ã€ä¼˜åŒ–æ”¹è¿›

### å˜æ›´æµç¨‹
1. **å˜æ›´ç”³è¯·**ï¼šæäº¤å˜æ›´è¯·æ±‚å•
2. **å½±å“è¯„ä¼°**ï¼šè¯„ä¼°å˜æ›´é£é™©å’Œå½±å“
3. **å˜æ›´å®¡æ‰¹**ï¼šè·å¾—å¿…è¦çš„å®¡æ‰¹
4. **å˜æ›´å®æ–½**ï¼šæŒ‰è®¡åˆ’æ‰§è¡Œå˜æ›´
5. **å˜æ›´éªŒè¯**ï¼šéªŒè¯å˜æ›´æ•ˆæœ
6. **å˜æ›´å…³é—­**ï¼šæ›´æ–°æ–‡æ¡£å’Œè®°å½•

## ğŸ“‹ æ•…éšœé¢„æ¡ˆ

### æ•°æ®åº“æ•…éšœ
1. æ£€æŸ¥æ•°æ®åº“è¿æ¥çŠ¶æ€
2. æŸ¥çœ‹æ•°æ®åº“æ—¥å¿—
3. æ£€æŸ¥ç£ç›˜ç©ºé—´
4. é‡å¯æ•°æ®åº“æœåŠ¡
5. å¯ç”¨å¤‡ç”¨æ•°æ®åº“

### APIæœåŠ¡æ•…éšœ
1. æ£€æŸ¥æœåŠ¡çŠ¶æ€
2. æŸ¥çœ‹åº”ç”¨æ—¥å¿—
3. æ£€æŸ¥å¤–éƒ¨ä¾èµ–
4. é‡å¯åº”ç”¨æœåŠ¡
5. å¯ç”¨é™çº§æ–¹æ¡ˆ

### æ”¯ä»˜ç³»ç»Ÿæ•…éšœ
1. ç¡®è®¤æ”¯ä»˜æ¥å£çŠ¶æ€
2. æ£€æŸ¥ç½‘ç»œè¿æ¥
3. éªŒè¯APIå¯†é’¥
4. è”ç³»æ”¯ä»˜æœåŠ¡å•†
5. å¯ç”¨å¤‡ç”¨æ”¯ä»˜æ–¹å¼
```

---

## ğŸ¯ æ€»ç»“ä¸å±•æœ›

### ğŸ“ˆ é¡¹ç›®ä»·å€¼æ€»ç»“

**CuttingASMR.org**ä½œä¸ºä¸€ä¸ªåˆ›æ–°çš„AIé©±åŠ¨ASMRè§†é¢‘ç”Ÿæˆå¹³å°ï¼Œåœ¨æŠ€æœ¯æ¶æ„ã€å•†ä¸šæ¨¡å¼å’Œç”¨æˆ·ä½“éªŒæ–¹é¢éƒ½å±•ç°äº†æ˜¾è‘—çš„åˆ›æ–°æ€§å’Œå®ç”¨æ€§ï¼š

#### ğŸ† æ ¸å¿ƒæŠ€æœ¯ä¼˜åŠ¿
1. **åŒAPIæ¶æ„åˆ›æ–°**ï¼šé«˜çº§API + ç®€å•APIçš„å›é€€æœºåˆ¶ï¼Œç¡®ä¿æœåŠ¡é«˜å¯ç”¨æ€§
2. **æ™ºèƒ½ç§¯åˆ†ç³»ç»Ÿ**ï¼šçµæ´»çš„ç§¯åˆ†åˆ¶æ¶ˆè´¹æ¨¡å¼ï¼Œæä¾›è‰¯å¥½çš„ç”¨æˆ·ä½“éªŒ
3. **å¤šå±‚ç¼“å­˜ç­–ç•¥**ï¼šEdge Runtime + APIå¯†é’¥æ± ï¼Œä¼˜åŒ–æ€§èƒ½å’Œæˆæœ¬
4. **å…¨çƒCDNéƒ¨ç½²**ï¼šCloudflare + RailwayåŒå¹³å°ï¼Œä¿éšœå…¨çƒè®¿é—®é€Ÿåº¦

#### ğŸ’¼ å•†ä¸šä»·å€¼ä½“ç°
1. **å¸‚åœºå®šä½ç²¾å‡†**ï¼šç„å‡†ASMRå¸‚åœºï¼Œæ»¡è¶³ä¸ªæ€§åŒ–å†…å®¹éœ€æ±‚
2. **æ”¶å…¥æ¨¡å¼åˆ›æ–°**ï¼šçº¯ç§¯åˆ†åˆ¶é¿å…è®¢é˜…ç–²åŠ³ï¼Œæé«˜ç”¨æˆ·æ¥å—åº¦
3. **æŠ€æœ¯é—¨æ§›è¾ƒé«˜**ï¼šAIæŠ€æœ¯æ•´åˆä¸ä¼˜åŒ–å½¢æˆç«äº‰å£å’
4. **æ‰©å±•æ€§è‰¯å¥½**ï¼šæ¶æ„è®¾è®¡æ”¯æŒå¿«é€Ÿä¸šåŠ¡å¢é•¿

#### ğŸ¨ ç”¨æˆ·ä½“éªŒåˆ›æ–°
1. **æç®€æ“ä½œæµç¨‹**ï¼šè¾“å…¥æç¤ºè¯å³å¯ç”Ÿæˆä¸“ä¸šASMRè§†é¢‘
2. **ä¸ªæ€§åŒ–å®šåˆ¶**ï¼šæ”¯æŒå¤šç§å‚æ•°è°ƒèŠ‚ï¼Œæ»¡è¶³ä¸åŒéœ€æ±‚
3. **å¿«é€Ÿåé¦ˆæœºåˆ¶**ï¼šå®æ—¶è¿›åº¦æ˜¾ç¤ºï¼Œé™ä½ç”¨æˆ·ç­‰å¾…ç„¦è™‘
4. **å¤šè®¾å¤‡é€‚é…**ï¼šå“åº”å¼è®¾è®¡ï¼Œæ”¯æŒå…¨å¹³å°è®¿é—®

### ğŸš€ æœªæ¥å‘å±•æ–¹å‘

#### çŸ­æœŸç›®æ ‡ï¼ˆ6ä¸ªæœˆå†…ï¼‰
- **ç”¨æˆ·è§„æ¨¡**ï¼šè¾¾åˆ°1ä¸‡æ³¨å†Œç”¨æˆ·ï¼Œæ—¥æ´»è·ƒç”¨æˆ·1000+
- **æŠ€æœ¯ä¼˜åŒ–**ï¼šè§†é¢‘ç”ŸæˆæˆåŠŸç‡æå‡è‡³95%ï¼Œå“åº”æ—¶é—´ç¼©çŸ­è‡³1.5ç§’
- **åŠŸèƒ½æ‰©å±•**ï¼šå¢åŠ å¤šç§è§†é¢‘é£æ ¼ï¼Œæ”¯æŒè‡ªå®šä¹‰æ—¶é•¿
- **å¸‚åœºæ¨å¹¿**ï¼šSEOä¼˜åŒ–ï¼Œç¤¾äº¤åª’ä½“æ¨å¹¿ï¼Œç”¨æˆ·å¢é•¿è®¡åˆ’

#### ä¸­æœŸç›®æ ‡ï¼ˆ1å¹´å†…ï¼‰
- **å¹³å°ç”Ÿæ€**ï¼šæ„å»ºå†…å®¹åˆ›ä½œè€…ç¤¾åŒºï¼Œæ¨å‡ºåˆ›ä½œè€…æ¿€åŠ±è®¡åˆ’
- **æŠ€æœ¯å‡çº§**ï¼šæ¥å…¥æ›´å¤šAIæ¨¡å‹ï¼Œæä¾›æ›´ä¸°å¯Œçš„ç”Ÿæˆé€‰é¡¹
- **å›½é™…åŒ–**ï¼šæ”¯æŒå¤šè¯­è¨€ï¼Œæ‹“å±•æµ·å¤–å¸‚åœº
- **å•†ä¸šå˜ç°**ï¼šæœˆæ”¶å…¥çªç ´10ä¸‡å…ƒï¼Œå®ç°ç›ˆäºå¹³è¡¡

#### é•¿æœŸæ„¿æ™¯ï¼ˆ3å¹´å†…ï¼‰
- **è¡Œä¸šé¢†å¯¼**ï¼šæˆä¸ºASMR AIç”Ÿæˆé¢†åŸŸçš„æŠ€æœ¯å’Œå¸‚åœºé¢†å¯¼è€…
- **æŠ€æœ¯åˆ›æ–°**ï¼šæ¨å‡ºå®æ—¶è§†é¢‘ç”Ÿæˆã€3Dè§†é¢‘ã€VRä½“éªŒç­‰å‰æ²¿åŠŸèƒ½
- **ç”Ÿæ€å»ºè®¾**ï¼šæ‰“é€ å®Œæ•´çš„AIå†…å®¹åˆ›ä½œç”Ÿæ€ç³»ç»Ÿ
- **å…¨çƒæ‰©å¼ **ï¼šå»ºç«‹å…¨çƒæœåŠ¡ç½‘ç»œï¼ŒæœåŠ¡å…¨çƒç”¨æˆ·

### ğŸ“Š æˆåŠŸæŒ‡æ ‡ä½“ç³»

#### æŠ€æœ¯æŒ‡æ ‡
- **ç³»ç»Ÿå¯ç”¨æ€§**ï¼š99.9% â†’ 99.95% â†’ 99.99%
- **å¹³å‡å“åº”æ—¶é—´**ï¼š2ç§’ â†’ 1.5ç§’ â†’ 1ç§’
- **è§†é¢‘ç”ŸæˆæˆåŠŸç‡**ï¼š90% â†’ 95% â†’ 98%
- **APIå¯†é’¥åˆ©ç”¨ç‡**ï¼š70% â†’ 85% â†’ 95%

#### ä¸šåŠ¡æŒ‡æ ‡
- **ç”¨æˆ·å¢é•¿ç‡**ï¼šæœˆå¢é•¿30%
- **ç”¨æˆ·ç•™å­˜ç‡**ï¼š7æ—¥ç•™å­˜50%ï¼Œ30æ—¥ç•™å­˜30%
- **ä»˜è´¹è½¬åŒ–ç‡**ï¼š15% â†’ 25% â†’ 35%
- **ARPU**ï¼š$15 â†’ $25 â†’ $40

#### äº§å“æŒ‡æ ‡
- **ç”¨æˆ·æ»¡æ„åº¦**ï¼š4.5/5æ˜Ÿ
- **NPSå¾—åˆ†**ï¼š50+
- **åŠŸèƒ½ä½¿ç”¨ç‡**ï¼šæ ¸å¿ƒåŠŸèƒ½ä½¿ç”¨ç‡80%+
- **å®¢æœå“åº”æ—¶é—´**ï¼š1å°æ—¶å†…å“åº”ç‡95%

### ğŸ’¡ æŒç»­æ”¹è¿›æœºåˆ¶

#### æŠ€æœ¯ä¼˜åŒ–
- **æ¯æœˆæŠ€æœ¯è¯„å®¡**ï¼šè¯„ä¼°æ¶æ„æ€§èƒ½ï¼Œä¼˜åŒ–ç“¶é¢ˆç‚¹
- **å­£åº¦æ¶æ„å‡çº§**ï¼šå¼•å…¥æ–°æŠ€æœ¯ï¼Œæå‡ç³»ç»Ÿèƒ½åŠ›
- **å¹´åº¦æŠ€æœ¯é‡æ„**ï¼šåŸºäºä¸šåŠ¡å‘å±•è°ƒæ•´æŠ€æœ¯æ¶æ„

#### ç”¨æˆ·ä½“éªŒ
- **ç”¨æˆ·åé¦ˆæ”¶é›†**ï¼šå¤šæ¸ é“æ”¶é›†ç”¨æˆ·æ„è§å’Œå»ºè®®
- **æ•°æ®é©±åŠ¨å†³ç­–**ï¼šåŸºäºç”¨æˆ·è¡Œä¸ºæ•°æ®ä¼˜åŒ–äº§å“åŠŸèƒ½
- **A/Bæµ‹è¯•éªŒè¯**ï¼šæ–°åŠŸèƒ½é€šè¿‡A/Bæµ‹è¯•éªŒè¯æ•ˆæœ

#### å›¢é˜Ÿå‘å±•
- **æŠ€èƒ½æå‡è®¡åˆ’**ï¼šå®šæœŸæŠ€æœ¯åŸ¹è®­ï¼Œæå‡å›¢é˜Ÿèƒ½åŠ›
- **çŸ¥è¯†åˆ†äº«æœºåˆ¶**ï¼šå†…éƒ¨æŠ€æœ¯åˆ†äº«ï¼Œä¿ƒè¿›çŸ¥è¯†ä¼ æ’­
- **åˆ›æ–°æ¿€åŠ±åˆ¶åº¦**ï¼šé¼“åŠ±æŠ€æœ¯åˆ›æ–°å’Œæµç¨‹æ”¹è¿›

---

**æœ¬æ¶æ„æ–‡æ¡£å°†éšç€é¡¹ç›®å‘å±•æŒç»­æ›´æ–°å’Œå®Œå–„ï¼Œä¸ºCuttingASMR.orgçš„æˆåŠŸæä¾›åšå®çš„æŠ€æœ¯ä¿éšœå’Œå‘å±•æŒ‡å¼•ã€‚**

---

*æ–‡æ¡£ç‰ˆæœ¬ï¼šv1.0*  
*æœ€åæ›´æ–°ï¼š2024å¹´11æœˆ*  
*ç»´æŠ¤å›¢é˜Ÿï¼šCuttingASMRæŠ€æœ¯å›¢é˜Ÿ*

---

## ğŸ”„ æŒç»­æ›´æ–°è¯´æ˜

æœ¬æ–‡æ¡£å°†éšç€é¡¹ç›®å‘å±•æŒç»­æ›´æ–°ï¼Œå·²å®Œæˆéƒ¨åˆ†ï¼š
- âœ… ç¬¬ä¸€éƒ¨åˆ†ï¼šé¡¹ç›®æ€»è§ˆä¸æˆ˜ç•¥å®šä½
- âœ… ç¬¬äºŒéƒ¨åˆ†ï¼šæŠ€æœ¯æ¶æ„è®¾è®¡
- âœ… ç¬¬ä¸‰éƒ¨åˆ†ï¼šæ•°æ®æ¶æ„è®¾è®¡
- âœ… ç¬¬å››éƒ¨åˆ†ï¼šå®‰å…¨æ¶æ„
- âœ… ç¬¬äº”éƒ¨åˆ†ï¼šæ”¯ä»˜ä¸ä¸šåŠ¡é€»è¾‘æ¶æ„
- âœ… ç¬¬å…­éƒ¨åˆ†ï¼šAIé›†æˆæ¶æ„
- âœ… ç¬¬ä¸ƒéƒ¨åˆ†ï¼šéƒ¨ç½²ä¸è¿ç»´æ¶æ„
- âœ… ç¬¬å…«éƒ¨åˆ†ï¼šæµ‹è¯•æ¶æ„
- âœ… ç¬¬ä¹éƒ¨åˆ†ï¼šæ•°æ®åˆ†æä¸ç›‘æ§æ¶æ„
- âœ… ç¬¬åéƒ¨åˆ†ï¼šDevOpsä¸CI/CDæ¶æ„
- âœ… ç¬¬åä¸€éƒ¨åˆ†ï¼šæ‰©å±•æ€§ä¸æœªæ¥è§„åˆ’
- âœ… ç¬¬åäºŒéƒ¨åˆ†ï¼šæ–‡æ¡£ä¸è§„èŒƒ

**æ›´æ–°é¢‘ç‡**ï¼šæ¯ä¸ªSprintç»“æŸåæ›´æ–°ä¸€æ¬¡  
**ç»´æŠ¤è´£ä»»äºº**ï¼šæŠ€æœ¯æ¶æ„å¸ˆ  
**å®¡æ ¸æµç¨‹**ï¼šå›¢é˜Ÿè¯„å®¡ â†’ æŠ€æœ¯ç»ç†å®¡æ‰¹ â†’ å‘å¸ƒæ›´æ–°

---

*æœ¬æ–‡æ¡£éµå¾ªMITå¼€æºåè®®ï¼Œæ¬¢è¿å›¢é˜Ÿæˆå‘˜è´¡çŒ®æ”¹è¿›å»ºè®®* 